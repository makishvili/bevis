# BEViS & bt

##Тезисы

_Бивис — еще один подход в разработке сайтов, который придумали в Яндексе. Это простая и понятная модель разработки, которая подходит для больших проектов, повышает их надежность._

_Это будет дружеский рассказ, такой можно услышать в офисных коридорах или на кофепойнте. Мы расскажем, как верстаем свои проекты, и почему отныне уверены в их стабильности. Вдруг и вам Бивис
приглянётся :)_

_Вы всё поймёте с первого раза. Обещаем ;)_

##Начало

Привет, я Вадим, это мой друг Марат. Мы из Яндекса. Из Карт.
Спасибо, что пригласили :)

Мы любим строить сайты. И нам хочется получать от этого удовольствие.
Теперь мы получаем радость, потому что придумали Бивис.

Если вы работаете в команде, в которой больше 4-5 человек, разрабатываете сервис, в котором много
похожих блоков или страниц, или вы разработываете общую библиотеку блоков, тогда бивис и для вас тоже.

Сразу признаемся. У нас нет цели заполучить вас в контрибьютеры или принести вам новую веб-религию. Мы не
претендуем на мировые лавры. Мы просто с вами по-братски делимся своими придумками.

Ну всё, хватит общих слов, давайте к станку!

## Приложение

Как работает веб-приложение? Схематично это выглядит так.

[Слайд](http://makishvili.github.io/bevis/index.html?full#2)

Запрос из браузера попадает на некий http-сервер. Это может быть Apache или Nginx или любой другой.
Запрос направляется в контроллер - программу, написанную, например, на PHP или на Python, которая
 получает данные из бекенда (из MySql или серванта), и передаёт в шаблоны представления, кторые и генерят конечный html.

Эта схема известна каждому. Ну так мы её и не меняли. Мы поменяли технологии и шаблонизатор.

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

Вместо Apache или Nginx у нас Node.js. Вместо php-страничек мы пишем программу на серверном `js`, в которой обращаемся в сервант за данными,
накладываем на них шаблоны представления, которые тоже напсисаны на серверном `js`, и отдаём пользователю конечный `html`.

Видите - схема та же. Только всё на яваскрипте, на серверном яваскрипте.

----

Зачем изобретать новый велосипед, если есть Смарти, есть Джанга, есть XSLT, в конце концов?

Две причины: простота и ассинхронность. Простота в том, что сверстать приложение может любой школьник, который умеет на html/css/javascript
Ему не нужно учить новый язык программирования - ни PHP, ни Ruby, ни Python. Что ещё учить не надо - Perl, Java, C#, XSL, продолжайте. Я понимаю,
что у каждого языка свои преимущества в определённых ситуациях. Но мы и не говорим, что они не нужны. Мы говорим,
 что типовые задачи веб-разработки можно успешно делать на серверном javascript, который мы уже знаем.

И вторая причина - асинхронность. Для больших проектов важна скорость. Да и просто это модно, а мы ребята модные :)

Иными словами, мы захотели обрести полный контроль над фронтендом. Самое время! Есть все возможности!

----

Как выглядит контроллер в PHP или Python?
Это набор PHP/Puthon-команд, которые ходят в бекенд за данными.

Как выглядит наш контроллер `index.page.js?`
Это набор Javascript-команд. Так как мы пишем на Node.js, наш яваскрипт завернут в Node.js модули. И выглядит это примерно так:

```javascript
module.exports = function (pages) {

    pages.declare('index-page', function (params) {
        return {
            block: 'page',
            styles: 'index.css',
            scripts: 'index.js'

            body: [
                {
                    block: 'header'
                },
                {
                    block: 'authorization',
                    actionUrl: '/?task=login'
                }
            ]
        };
    });

};
```
Если вы на Node.js не писали, не пугайтесь, не обращайте внимания на первую строку. Относитесь к ней, как обвязке, без которой нельзя.
Всё интересное происходит внутри. А внутри обычный javascript. Видите вызов функции page.declare()?

В бивис-приложении есть модуль `page`, у которого есть метод `declare`. Выражаясь языком юристов, это "декларация о намерениях" :)
Мы декларируем, что наша страница будет состоять из нескольких компонентов и перечисляем  эти компоненты в каком-то простом формате.

Мы сказали, что страница состоит из блока `page`, в теле которого есть два других блока - `шапка` и `форма авторизации`.
Это абсолютно валидный `JSON`. Совершенно обычный `JSON`. Бивис создавался, как фреймворк, который использует совершенно валидные нативные конструкции.
В этом json есть только одно служебное поле, оно называется block. Остальные поля, которые вы видите, могу называться как вам нравится.

Почему блок? Зачем какой-то `JSON`? И что оно вообще такое?

Посмотрите на любую картину вблизи - это же хаос - цветные мазочки-мазочки-мазочки. Ни черта не разобрать.

[ утро в сосновом бору zoom x 10]()

А если отойти от картины - Оооо, так это де Шишкин Иван Иванович с его знаменитиыми мишками.

[ утро в сосновом бору zoom x 1]()

Так и мы отодвинулись от html-тегов и увидели, что верстаем-то не тегами, а некими компонентыми, модулями, блоками.
Мы абстрагировались от html-тегов. Мы больше не пишем их, потому что в Яндексе давно научились смотреть на веб-страницу,
как на набор компонентов, или блоков, как мы привыкли их называть. Каждый компонент выполняет свою простую функцию, вместе - это страница.

Вы, скорее всего, тоже разбиваете страницу на небольшие части, и называете их про себя как-то: кто модулями,
кто ещё как. Мы называем блоками, потому что мы из Яндекса, а там родилась концепция верстки абсолютно независимыми блоками,
в которой впервые прозвучало слово "блок". :)

## Описание страницы обязано быть простым

####Чем проще описание, тем легче пользоваться

Это важно. Чем предмет проще, тем легче им пользоваться. Тем больше удовольствия от использования.

Бабушка моей жены любит печь хлеб сама. Мы подарили ей хлебопечку. Казалось бы - насыпь муки, дрожжей,
налей воды и масла и нажми пару кнопок - очень просто. Но бабушка Дуся не пользуется. Она не может запомнить
в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Она по-прежнему пользуется газовой духовкой - куда проще - поджечь комфорку, сунуть противень внутрь, закрыть дверцу.

Какой веб-фреймворк для верстки ни возьми, он в какой-то степени напоминает злебопечку. Или пульт от навороченного телевизора.
Пожилым людям из всего пульта нужно три кнопки: включить, сделать громче и переключить канал.

Мы с Маратом люди пожилые. И в отделе у нас работают ребята, которым уже за тридцать, а кому-то и под сорок, как мне :)
Нам надоело это безобразие. Описывать страницу тегами, размечать их кастомными атрибутами  - это неоправданно сложно.
Слишком много суеты, слишком мало смысла.

Вот простое описание страницы.
```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Здесь сказано, что на странице будет два блока - шапка и форма авторзации. Здесь нет ни одного тега, ни одного атрибута. Но такого описания достаточно, чтобы Бивис сгенерил полноценный
развесистый html, например такой:

```
<div class="header">
    <a class="header__logo" href="/"><img src="logo.png" /></a>

    <h1 class="header__title">Демо-страница</h1>

    <a class="header__rss" href="/?rss"><img src="rss.png" /></a>
</div>

<form class="authorization" action="/?task=login">
    <input class="authorization__login" value=""/>
    <button class="authorization__submit"/>
</form>
```

Или даже больше.

Верстая на Бивисе, мы больше не верстаем html-тегами. Мы верстаем простыми абстракциями - блоками.
Это не наша гениальная идея. Любой верстальщик, когда получает эскиз сайта от дизайнера, смотрит на него и
видит не теги, которые будет в html-файле. Он видит какие-то абстракные блоки. Ага - это будет шапка, это подвал,
тут форма авторизации, а здесь меню. Это всё в нашем понимании блоки. Ну что поделать, если в русском языке не
нашлось более точного слова. Как Виталий Харисов в 2006 году произнёс это слово в докладе про верстку
независимыми блоками, так оно у нас в обиходе и осталось. Ну и пусть.

Скорее всего вы называете эти же блокаи как-то иначе. Или вообще не называете, потому что надобности в этом
не испытываете :)

А если вы не верстальщик, а настоящий программист, то вам станет яснее, когда я скажу, что блоком мы называем
примерно такую же асбтракцию, как паттерн "Модуль" в javascript.

Эдди Османи [говорит](http://largescalejs.ru/module-pattern/):
> «Модуль» — это популярная реализация паттерна, инкапсулирующего приватную информацию, состояние и структуру...


####Чтобы пользоваться блоком, достаточно одного имени

И мы в Бивисе сделали одну крутую вещь: чтобы на странице появился блок, его достаточно позвать на странице только по имени.
Всё, больше о нём мне ничего знать не нужно. Вот, вообще не нужно.

И это так по человечески. Ведь,
когда я хочу позвать к себе в гости Марата, я делаю этоочень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена яблочный пирог испечёт, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову его отдельно, отдельно его жену и каждого ребенка в отдельности. Нет, только его,
а уж он сам приведеёт всё семейсвто, будьте уверены.

```javascript
{
    друг: 'Марат'
}
```

И с блоком так же. Я НЕ ХОЧУ думать, о том, как он внутри устроен, из каких элементов. Я зову его просто по имени. Ну
 и если надо сообщаю блоку какую-то дополнительную информацию. Командир в окопе кричит сержанту: "Сержант Петренко,
 прикрыть правый фланг!".

```javascript
{
    рядовой: 'Петренко',
    прикрывает: 'правый фланг'
}
```
Всё! Командир приказал — Петренко сделал. И пусть Петренко сам решает, как это делать — то ли вести самому автоматный огонь
в указанном направлении, то ли гранатами точку подавлять, то ли других бойцов послать штурмом фланг занять. Командиру
какое дело до этих деталей вообще?

Ну что, похоже на правду?

```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Пусть блоки сами решают, в какой html они должны превратиться, чтобы лучшим образом выполнить свою задачу.
Как они устроен внутри, я как пользователь блока, думать не хочу.

Ну, в самом деле, я когда в ресторан прихожу, и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша,
нагрей суп в кастрюле, потом налей два половника в глубокую тарелку,
насыпь сверху зелени и сметаны ложку и только после этого неси мне." Нет, я просто говорю: "Мне солянку". Я точно
знаю, что в кафе солянка уже сварена, её сейчас мне подадут.

И с шапкой так же: "Мне шапку!"

```javascript
{
    block: 'header'
}
```

И за это я люблю Бивис. Создавать страницы из готовых блоков никогда не было ещё так просто.

####Блок - триединство структура-представление-поведение

Вы замечали, что любое изобретение человека может существовать только тогда, когда оно не противоречит законам природы?
Квадратное колесо не прижилось, хотя человек пытался наладить его промышленный выпуск. А чё? Его легче производить,
легче транспортировать к точкам продажи, легче устанавливать. Но квадратное не может катиться.
Это закон физической природы. Против него идти глупо.

Всё, что создано человеком и смогло сохраниться веками - это то, что следует законам природы, а не противоречит.

Блок - это очень жизненная абстракция. Блок, как божья тварь, состоит из трёх Начал.
Чтобы было понятнее, представьте меня в виде модуля, в виде блока:

1. У меня есть скелет, мышцы и внутренние органы. Это моя структура. У блока эту роль выполянет HTML-разметка.
2. У меня есть какой-то рост, вес, цвет кожи и выражение лица. Это мой внешний вид. У блока эту роль выполняют CSS-стили.
3. Я сейчас размахиваю руками и говорю с вами со сцены. Это моё поведение. Блок тоже умеет как-то взаимодействовать с пользователем на странице.

Природа создала человека - очень сложный модуль, со сложным внутренним строением, с разнообразным внешним видом,
с самым непредсказуемым поведением. А человек подглядел это решение, и по образу и подобию научился делать блоки для веб-страниц.

Мы такую красивую аналогию вам привели, когда вы в ресторане солянку заказали. Эффектно, да?
Но в жизни мы в рестоарны редко ходим. Обычно я ужинаю дома. И если я попробую дома сказать жене: "Хочу на
ужин борщ с фасолью, и сметаной", а потом на диван сяду и в iPad уткнусь, ожидая, что через пару минут
передо мной окажется тарелка ароматного борща, знаете, что я услышу в ответ?

— Легко! Картошку почисть!

Да, такова жизнь. Жёнам нужно помогать. Это аксиома.

Когда вы начинаете разрабатывать сайт и глядя на эскиз,
представляете из каких блоков построите страницу, вы описываете сайт на уровне абстракций. Но ведь потом
вам придётся длоя этих абстракций сгенерить нужный html, нужные стили и клиентский javascipt, потому что браузеры
понимают только эти технологии. И никто кроме вас этого не сделает.

##HTML-структура

### Императивные шаблоны

Как мы генерим html в смарти, джанго и других MVC?

Мы пишем шаблоны, которые выглядят, как html-код, в который точечно добавляются данные. Как будто шприцом обкалываем:
```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервиcный центр.</p<
{% endif %}
```

Эти шаблоны мы пишем вот в этом месте.

[слайд-схема с index.tpl.php]()

И с такими шаблонами есть проблема. Как на другой странице вылить этот же список?
Придётся и там писать тот же ul и тот же цикл. Реиспользовать представление становится труднее.

В бивисе мы решаем эту задачу с помощью декларативных шаблонов.

### Декларативные шаблоны

На `XSLT` писали? `XML` в `HTML` трансформировали? Тогда вы нас понимаете - шаблоны как в `XSLT`
А кто не писал на `XSL`, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это CSS-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

`CSS`-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо инъекций шприцем (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Это как горчичники - если есть куда их приложить - доктор их обязательно приложит.
Горчичники заматчатся или не заматчатся.

Вспомним нашу схему.

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

Браузер запрашивает страницу, сервер обрабатывает ваш запрос, создаёт декларацию страницы в формате `btjson`

Предположим, наш контроллер выглядит так - на странице мы хотим видеть одну только шапка. Больше никаких блоков.

```javascript
module.exports = function (pages) {

    pages.declare('index-page', function (params) {
        return {
            block: 'header'
        }
    });
};
```

Фактически, мы видим декларацию только одного блока. Не смотрите на всю мишуру вокруг, сконцентрируйтесь только на этом json:

```javascript
{
    block: 'header'
}
```

Мы хотим, чтобы из этого json-а на странице появился такой html:
```html
<div class="header"></div>
```

Декларативный шаблон мог бы выглядеть почти, как в CSS

```javascript
header {
    setTag: div;
}
```

Этот шаблон бы читался так: если на странице объявлен блок header, вылей для него тег div.
В реальности, мы почти так и пишем, только на чистом валидном javascript:

Это шаблон на Бивисе:
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Похоже на это, правда?
```javascript
header {
    setTag: div;
}
```

Шаблон записывается в виде функции `match`, в которую мы первым параметром передаём имя блока.
А вторым аргументом пишем функцию, внутрь которой приходит исходный `btjson` в переменной `ctx`
А в функции сказано - создай тег `div`

Функция `match` - это метод шаблонизатора `bt`. `BT` - это и есть повар в ресторане или ваша жена на кухне.
У шаблонизатора прекрасная документация, которую поймёт даже школьник, почитайте.

Так что же такое "матчинг", наложение шаблонов?

В CSS вы такой шаблон знаете под именем "селектор" (от английского to select), потому что селектор как бы
выбирает блоки, к которым нужно применить стилевые свойства, а в других декларативных языках эта же
декларация зовётся "шаблоном" (трудно сказать почему). И ещё говорят, что шаблон матчится на
блок (от английского to match, что переводится, как "подбирать", "приводить в соответствие").
Кстати to select имеет те же самые значения, что и to match. То есть это равнозначные слова с одинаковым смыслом :)

Матчинг - это и есть селекция, выбор, проверка совпадения условий в селекторе (матчере).
То же самое, что вы делаете, когда пишете CSS-стили.

Только эти шаблоны вы пишете не в css-файле, а в index.bt.js.
Посмотрите ещё раз на схему, чтобы соориентироваться.
В SMARTy шаблоны хранятся в `index.tpl.php`, а у нас в `index.bt.js`

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

А теперь вернёмся к шаблону
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Он довольно бесполезный. Чтобы вылить тег, столько всего написать надо.
Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок.

Я добавил комментарии в код, чтобы вы всё поняли, а я помолчу.

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });
});

// регистрируем матчер для элемента title блока header
bt.match('header__title', function (ctx) {
    ctx.setTag('h1');

    // Получаем параметр text
    var text = ctx.getParam('text');

    // задаём содержимое заголовку
    ctx.setContent(text);
});
```

Результат:
```html
<div class="header">
    <h1 class="header__title">CodeFest 2014</h1>
</div>
```

А теперь сделаем шапку настраиваемой - чтобы можно было задавать текст заголовка на жестко, а гибко.
Предполагаю, что имя заголовка нам придёт из базы и контроллер создаст `btjson` с параметром блока, назовём его `text`
Давайте сходим в базу за текстом заголовка:

```javascript
var http = require('http'); // подключили Nodejs-модуль для http-запросов

module.exports = function (pages) {

    var headerTitle = http.get(...); // здесь сходили в базу и получили ответ

    pages.declare('index-page', function (params) {
        return {
            block: 'header'
            text: headerTitle // здесь подставили значение из базы
        }
    });

};
```

Изменим одну строку в шаблоне — будем принимать значение параметра:

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
    ctx.setContent({
        elem: 'title',
        text: ctx.getParam('text') // получаем значение из параметра
    });
});


bt.match('header__title', function (ctx) {
    ctx.setTag('h1');
    var text = ctx.getParam('text');
    ctx.setContent(text);
});
```

Наш результат — из базы пришёл свежий твит про наше вступление:

```html
<div class="header">
    <h1 class="header__title">twitter: Парни из Яндекса рассказывают про BEViS на #codefest. Приколисты!</h1>
</div>
```

Но это всё синтетические примеры. Посмотрим на реальный пример их Яндекса. Это описание шапки.
В нём одно обязательно поле - имя блока, остальные поля - это необязательные параметры, опции:

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Так оно выглядит в браузере:

[живое демо]

#### Это оверхед?
Вам кажется это избыточным? Вам привычнее императивные шаблоны вроде тех, что есть в Смарти и в Джанго. Мы вас понимаем.
Кажется, что те шаблоны писать проще - написал html страницы, заменил контент шаблонными переменными и всё.

Но как смарти-шаблоны обеспечивают вам реюзабельность одних и тех же блоков на разных страницах? Как эти шаблоны гарантируют стабильную верстку?
Никак. Когда вы захотите заменить верстку какого-то блока с дивов на табличку, вам придётся сделать это во всех Смарти-шаблонах, где этот блок уже описан.
И попробуйте сказать, что ни разу при этом не ошибётесь. Мы не поверим :)

Наш подход хорош тем, что на старнице нет описания того, КАК должен выглядеть блок, а только само указание, что "здесь есть такой-то блок и
у него такие-то параметры". Это же прям как в настоящем программированнии - вызов класса с передачей в него параметров.
Класс выставляет наружу интерфейсные методы, которые не меняются и поддерживаются пожизненно, а внутрення реализация класса скрыта от глаз,
находится в приватной области.

Мы создали то же самое для html-верстки.

BTJson блока - это внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на примере. При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Но самое ценное в том, что отныне можете менять шаблоны, генерирующие html как угодно часто, вам не нужно при этом переписывать
все страницы. И не бояться, что на какой-то странице что-то пойдёт не так. АПИ блока гарантирует результат.

Кто из вас читал про Web Components?
Бивис реализует ровно эту же идею, которая лежит в основе развивающихся Web Components: семантика отдельно, теневое дерево отдельно.
Только веб-компоненты пока нельзя использовать для продакшена, а бивис уже можно ;)

Кто-то может возразить, что мы пишем больше кода - каждый декларативный шаблон нужно явно описать, там задать какой тег выливать,
какие элементы внутри блока генерить. Ну так вы же на Смарти шаблонах тоже всё это пишете, только в виде чистого html. А мы пишем это на js.

Вы скажете, что мы пишем куда больше букв и вдоказателсьвто приведёте эти две строки.
```javascript
ctx.setTag('div'); // 18 символоа
```

```html
<div></div> <!-- 11 символов -->
```

Да, наша запись на семь символов длиннее, но только при условии, что вы руками пишете каждый символ, когда пишете теги.
Вы же не в `notepad.exe` код пишете, надеюсь?

Вы пользуетесь аутокомплитом, то есть написали открывающую скобку, затем букву `d` и нажали хоткей для аутокомплита.
Или если [Дзен-кодингом](http://pepelsbey.net/2008/08/zen-html/) набираете html, который придумал Вадим Макеев, а разработал Сергей
Чикуёнок, и теперь он называется [Emmet](http://emmet.io/), тогда вы вообще пишете три символа `div` и нажимаете `tab`.

Ну, а мы пользуемся сниппетами. Нажал хоткей, вписал только три символа `div` и у нас готова строка ```ctx .setTag ('div');```

Я веду к тому, что вы пишете императивные шаблоны, а мы декларативные, и прикладываем мы с вами сравнительно одинаковое количество сил для написания шаблонов.


#### View блока

Имя у блока может быть простым — просто Марат, или просто Вадим, или просто header. Но бывают случаи, когда оно должно быть более точным.
Например, Марат Дулин, или Вадим Макишвили. Чтобы добавить в имя уникальности.

Кого из вас зовут Вадим?

Представьте, вбегает сейчас в зал (вон в ту дверь) организатор конференции и кричит: "Эй, Вадим, в продакшене 404 ошибка на главной странице!".
Сколько Вадимов встрепенётся и занервничает? Да, все Вадимы. Но если он крикнет "Вадим Макишвили", то встрепенусь только я.

Жизнь доказывает, что имени и фамилии достаточно для идентификации человека.

Когда мы зовём block: 'header', мы зовём наш блок по имени. Но если мы хотим добавить ещё больше уникальности, мы добавляем здесь
же "фамилию", которую у блока мы именуем словом `view`

```javascript
{
    block: 'header',
    view: 'search'
}
```

Читать это следует так: создай на странице шапку, да не простую, а поисковую.
Получится такой HTML:

```html
<div class="header_search">
    ....
</div>
```

Понимаете, блок один - шапка, но на одной странице она может быть поисковая, а на другой непоисковая.
Поэтому у неё есть два варианта отображения на странице, два представления, две темы, два скина, две шкурки...
два `View`. Разный вид одного и того же блока мы называем разным преставлением. Разным `View`.

Это вью активно используем когда пишем стили.

## CSS-блока
Рассказ про CSS мы начнём с важного заявления, с которым кто-то из вас будет категорически несогласен.
Но тем интереснее, да? :)

Мы убеждены, что имя у блока должно быть одно. Мы не согласны с теми из вас, кто использует в верстке такой приём:

```
<div class="header authorization"></div>
```

Что это - шапка и форма авторизации одновременно? Это как? Я и папа, я и мама? Вы смотрели фильм Георгия Данелия "Мимино"?
Мимино - это главный герой - грузинский летчик из горного села. Играет Вахтанг Кикабидзе.
По сценарию Мимино прилетает в Москву, найти работу в большой авиации. Жить ему негде, в гостиницах мест нет.
Но знакомые знакомых договорились по блату поселить его в гостиницу, в которой как раз проводится всесоюзный слёт врачей-эндокринологов.
И чтобы Мимино заселили, ему нужно было на ресепшине солгать, что он тоже врач-эндокринолог.

И вот представьте. Мимино приходит в гостиницу. Синяя отутюженная форма лётчика. Погоны. Фуражка с эмблемой авиации.
И когда его удивлённо спрашивают "Вы, что — лётчик?", знаете, что он отвечает?

— Да. Иногда. Но, вообще-то, я эндокринолог.

Это смешно? А вот это не смешно? Я и шапка и авторизация? Хороший летчик не может быть одновременно хорошим эндокринологом.
И наоборот тоже, кстати. Попробуй совмещать обе профессии - сплошные проблемы будут. Такова жизнь, не нам с ней спорить.

И в верстке с множественными именами сплошные проблемы. Хаос и боль, потому что в CSS есть грандиозная проблема для больших веб-сайтов:

В `CSS` нет надёжного механизма разруливания весов стилевых селекторов. Какой селектор позже записан, тот и применится к тегу.
В нашем случае, если в стилевом файле селектор `.header {border-color: red}` записан позже селектора `.authorization {border-color: green}`,
то блок окажется окружён красным бордером. А если вдруг селекторы придут в обратном порядке - вокруг блока будет зелёный бордер.
А приходить они могут в разной последовательности, когда у вас динамическое построение `CSS`-файла.

Когда мы смешиваем два блока на одной `HTML`-ноде, нет способа влиять на эту ситуацию, нет возможности контролировать её.
Управлять ей. Точнее, он есть, но он вообще не гарантирует результат — надо загружать стилевые селекторы в "правильном" порядке,
собирать `CSS`-файл в "правильном" порядке.

А правильный — это какой? Как понять, в каком порядке, если есть возможность смешать два произвольных блока в произвольном порядке?
А если три блока? Или четыре? Количество сочетаний блоков на одной простой странице исчисляется тысячами.
Точно ли разработчик сможет учесть всё многообразие сочетаний? Сможет?

В `BEViS` мы отказались от смешивания блоков друг с другом. Нет миксов блоков на одной ноде - нет конфликтов.

#### Не смешивай несмешиваемое
_Придумай в название другие слова, нормальные._

Для чего верстальщик использует смешивание блоков на одной ноде?
Cлучай первый - чтобы не копировать какой-то набор стилей, которые трудно выделить в какой-то блок:
```
<div class="header clearfix"></div>
<div class="footer clearfix"></div>
```
Здесь верстальщик в класс ckearfix выделил стили, решающие проблему обтекания .

Это опасно! Когда вы решите что-то исправить в стилях ckearfix, вы не можете быть уверены,
что ваши новоые исправления не законфликтуют со стилями в header или footer. Вам придётся перетестировать весь проект,
чтобы убедитьмся, что верстка не сломалась в тех блоках, где к блокам подмешан клирфикс. И у вас нет ни одного механизма,
кроме ручного пребора каждой страницы. А если у вас SPA, и часть блоков не видна, потому что аякс... В-общем, верстка
становится нестабильной. Вы сами её делаете нестабильной (внимание!) ради удоства разработки.

Случай второй - чтобы обеспечить полиморфизм похожих блоков:
```
<div class="menu "></div>
<div class="menu menu-top"></div>
<div class="menu menu-bottom"></div>
```
Есть три меню, которые наследуют стили от класса menu, а в menu-top и menu-bottom какие-то доопределения или переопределения.

Точно такая же ситуация. Вы добавляете или изменяете какое-то свойство в базовый класс menu и у вас нет гаранитии, что
ваши исправления не придут в конфликт весов с доопределниями и переопределениями в menu-top и menu-bottom.
Это опасно.

Какие это к чертям независимые блоки, если они зависят друг от друга. Выдерни нигюю карту - рассыпется весь карточный домик.

Как поступает бивис-разработчик в первом случае?

Вместо этого
```
<div class="header clearfix"></div>
<div class="footer clearfix"></div>
```
Мы пишем
```
<div class="header"></div>
<div class="footer"></div>
```
Куда делись клирфикс-стили? Они копируются в стили шапки и подвала отдельно.

Как поступает бивис-разработчик во втором случае?

Вместо этого
```
<div class="menu "></div>
<div class="menu menu-top"></div>
<div class="menu menu-bottom"></div>
```
Мы пишем
```
<div class="menu "></div>
<div class="menu_top"></div>
<div class="menu_bottom"></div>
```
Мы делаем разные преставления одного блока, а в кадое новое представление копируются стили базового представления

Вот теперь это самые настоящие независимые блоки.

Во-первых, стили шапки и подвала действиетльно не зависят друг от друга. Как и стили разных вью у меню.
Во-вторых, шапка, как и отдельное вью меню, хранит в СВОИХ стилях всё нужное,чтобы правильно отобразиться на странице.
Вот это - реально абсолютно независимые блоки, о которых Виталий Харисов рассказывал в 2006 году.

Вы готовы возразить: "Это же копипаст!"
Да, копипаст.

А копипаст - это, что, восьмой смертный грех? Моисей на скрижалях записал, что нельзя копипастить
фрагменты кода? Откуда такой священный трепет перед копипастом?

Вы ответите, чтобы я не ёрничал, не в грехе дело. Вам важно иметь возможность быстро исправить ошибку в клирфиксе
в одном только селекторе, и это исправление моментально применится ко всем блокам, к которым клирфикс примешан.
Мол, это всё - ради гибкости проекта. Это наоборот повышает стабильность проекта.

Не обманывайтесь. Когда вы вносите изменения в примешанный класс, вы делаете это на свой страх и риск. Это игра вслепую.
Когда у вас маленький проект, делайте, не бойтесь. Найти все проблемные места легко. Но когда у вас большой сайт, каждое маленькое
изменение может привести к глобальному тестированию.

В большом проекте не возникает просто так требование: надо изменить поведение клирфикса. Там возниают задачи вида: надо
изменить поведение такого-то блока. Когда я изменил повдение шапки, я ничего не сломал в поведении подвала, и наоборот. То есть н
сервисе ничего не происходит без ведома разработчика. Только под контролем глаза. У врачей есть специальный термин — "под контролем глаза".
Это означает "под пристальным вниманием, полностью сознавая меру возложенной на себя ответственности".

Мы очень боимся, когда что-то происходит без нашего ведома. Потому что, если что-то может пойти не так, оно обязательно пойдёт.
Вам знакома такая трактовака "закона" Мерфи?

В Бивисе ничего не происзодит без вашего ведома. Только явно, только открыто.

Мы делаем это на сервере с помощью CSS-препроцессора.

----

показать как

----

* View и State - как часть отображения блока
* Сказать про автопрефиксер - сказать спасибо Ситнику за доклад в Минске, где впервые услышали про продукт и захотели.


## JS-поведение блока

## Сборка статики без боли
* ENB - блочные файлы -> страничные файлы
* Серевер для разработки и автоматической перегенерации
* Показать всю схему ответа от сервера, увязать всё вышесказанное

Блок - это очень близкая для человека абстракция. Что ещё общее у меня и веб-блока?

У меня есть дом — место, откуда я выхожу утром на работу и куда возвращаюсь каждый вечер. Ну, хорошо, это не дом. Это квартира в многоэтажке.
У блока тоже есть свой дом - место, где блок отдыхает и ждёт, когда его "позовут поработать" в веб-странице.
В корне проекта есть директория `/blocks`, в ней живут все блоки. Только в ней. Это дом блоков. Не ищите других мест.
Если блока здесь нет, больше нет нигде.

````
/blocks
    /header
        header.bt.js
        header.styl
        header.js
    /form
        form.bt.js
        form.styl
        form.js
````

Каждый блок хранится в своей собственной папке, где шаблоны для генераиции html в bt.js, стили в styl, клиентский яваскрипт в js.
Эффективно, хотя и не ново. Когда моя дочка готовится к математике, она на парту выкладывает учебник по математике, тетрадь по математике,
угольник и карандаш — всё, что нужно именно для урока математики. У нас так же - всё, что нужно для блока находится в одной папке.


"А когда учитель хочет проверить у всего класса собрать тетради на проверку, она ходит по рядам и забирает тетради с стопку.
У нас тоже есть такой сборщик. Но об этом чуть позже."

"Внутри бивиса есть сборщик. Какие вы знаете? Ant, Make, Grunt? Мы написали ещё один. Знакомьтесь - [ENB](https://github.com/enb-make/enb)"

Зачем он нужен, если есть другие? Наш сборщик отличается тем, что собирает любые проекты, которые строятся на модели node / target.
А второая причина - он очень быстрый. Прям очень-очень быстрый. Нереально быстрый. И в нём есть встроенный сервер, он автоматически отслеживает
изменения на фаловой системе и пересобирает файлы.

