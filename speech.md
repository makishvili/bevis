Привет, "Вадим Макишвили — это я" (с)

Я прилетел к вам с юга Украины, из Симферополя. Сейчас там тепло и солнечно. А у вас холодно и снег. Я у вас замёрз.
Мне никто не сказал, что здесь будет так холодно. :)

Но главное, что здесь, на конеференции, очень тепло, уютно и по-домашнему. Вы - прекрасны. Организаторы - чудесны. Спасибо вам большое, что позвали!

Я прилетел к вам не только для того, чтобы рассказать про Бивис, который мы придумали в Яндекс.Картах.
Текст этого доклада уже есть на гитхабе в виде статьи, ей можно прочитать хоть сейчас.

В первую очередь я хочу познакомить вас вас с необыкновенным человеком.

С человеком, который доказывает, что можно быть гениальным программистом и не быть занудой.

С человеком, который умеет не только писать качественный код, но писать документацию к коды.
Такую документацию, которую будет интересно читать живым людям.

С человеком, продукты которого набирают популярность и внутри и снаружи Яндекса.
И такие проекты, как jquery, bootstrap и angularjs, уже используют один из продуктов этого человека.

Итак, я с огромным удовольствием представляю вам моего хорошего друга и талантливейшего программиста — Марата Дулина!

**Марат:** Привет. Сегодня мы расскажем вам по Бивис — это полноценный фреймфорк, на котором можно сделать большой надёжный сайт.
Сейчас есть уже подобные решения, каждое со своими плюсами и минусами, у каждого свой порог сложности.
Наше решение очень простое. Сделать сайта на бивисе способен даже школьник, потому что школьнику нужно знать только html/css/js.
Об этом мы хотим рассказать сегодня.


**Вадим:** Мы вам честно признаемся, у нас нет никаких целей на этой презентации.
Мы не ищем контрибьюторов. Потому что особо контрибьютить у нас нечего.
Мы не говорим, что принесли вам новую веб-религию и вам срочно нужно бросать
свои велосипеды и пересаживаться на наш. Мы по-братски поделимся с вами своими придумками. Больше никаких целей - ни явных, ни скрытых.

Ну, что поехали? Ты готов, Марат? И я готов. Тогда начали!

Когда-то я программировал на PHP. Я тогда использовал Смарти-шаблонизатор. Возможно, вы когда-то писали на Python, использовали Джанго.
Что такое обычное MVC-приложение?

[Слайд](http://makishvili.github.io/bevis/index.html?full#2)

1. Запрос из браузера попадает на какой-то http-сервер. Это может быть Apache, может быть Nginx. Это совершенно не важно

2. Дальше запрос направляется в контроллер - программу, написанную, например, на PHP или на Python.
Контроллер выполняет две простых задачи - получить данные из бекенда (или напрямую из базы данных) и передать данные в шаблоны представления

3. Шаблоны сегенерят html, и ответ уйдёт назад в браузер.

Эта схема знакома каждому из нас. Так? Ну, так бивис работает по этой же схеме.

----
3 минуты 30 секунд

----

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

1. Вместо Apache или Nginx у нас Node.js.
2. Вместо `php`-страничек мы пишем контроллер на серверном `js`. Он ходит куда-то за данными и отдаёт в шаблоны.
3. Шаблоны, тоже написанные на серверном `js`, генерят `html`, и ответ уходит в браузер.

Давайте посмотрим внутрь бивис-контролера. Что там, Марат?

```javascript
pages.declare('index', function () {

    return [
        {
            block: 'header'
        },
        {
            block: 'authorization',
            actionUrl: '/?task=login'
        }
    ];

});
```

**Марат:** Обычный `javascript`. В бивис-приложении есть объект `pages`, у которого есть метод `declare`.
В нём мы декларируем, что `index`-страница будет состоять из двух компонентов - из шапки и формы авторизации.

Это обычный `JSON`. Вадим, ты как html-верстальшик, не скучаешь по html-тегам?

**Вадим:** нет, не скучаю.

Если посмотреть на любую картину вблизи - это же хаос - цветные мазочки-мазочки-мазочки. Ни черта не разобрать.

[ утро в сосновом бору zoom x 10]()

А если отойти от картины - О, так это де Шишкин Иван Иванович с его знаменитиыми мишками.

[ утро в сосновом бору zoom x 1]()

Ну, в самом деле, когда мы получаем эскиз сайта от дизайнера, мы смотрим на него и
видим не теги, которые будет в html-файле. Мы видим какие-то абстрактные блоки.

Ага - это будет шапка, это подвал, а тут форма авторизации. Кто-то называет это компонентами, модулями, контролами.

В Яндексе это называют блоками. Как Виталий Харисов в 2009 году произнёс это слово в докладе про верстку
независимыми блоками, так оно у нас в обиходе и осталось. Ну и пусть.

Бивис-блок - это очень простая декларация на JSON. Простота - это очень важно.
Чем предмет проще, тем легче им пользоваться. Тем больше удовольствия от использования.

Бабушка моей жены любит печь хлеб сама. Мы подарили ей хлебопечку. Казалось бы - насыпь муки, дрожжей,
налей воды и масла и нажми пару кнопок - очень просто. Но бабушка Дуся не пользуется. Она не может запомнить
в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Она по-прежнему пользуется газовой духовкой - куда проще - поджечь комфорку, сунуть противень внутрь, закрыть дверцу.

Какой веб-фреймворк для верстки ни возьми, он в какой-то степени напоминает хлебопечку. Мы с Маратом люди пожилые. И в отделе у нас работают ребята, которым уже за тридцать, а кому-то и под сорок, как мне :)
Нам надоело описывать страницу тегами, размечать их атрибутами - это неоправданно сложно. Слишком много суеты, слишком мало смысла.

Поэтому вот так, мы решили, должно выглядеть описание страницы. Максимально просто, максимально плоско.

```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Здесь сказано, что на странице будет два блока - шапка и форма авторзации. Здесь нет ни одного тега, ни одного атрибута.
Но такого описания достаточно, чтобы Бивис сгенерил полноценный развесистый html, например такой:

```
<div class="header">
    <a class="header__logo" href="/"><img src="logo.png" /></a>

    <h1 class="header__title">Демо-страница</h1>

    <a class="header__rss" href="/?rss"><img src="rss.png" /></a>
</div>

<form class="authorization" action="/?task=login">
    <input class="authorization__login" value=""/>
    <button class="authorization__submit"/>
</form>
```

####Чтобы пользоваться блоком, достаточно одного имени

И мы в Бивисе сделали одну крутую вещь, которой гордимся-гордимся.

Чтобы на странице появился блок, его достаточно позвать на странице только по имени. Всё, больше о нём мне ничего знать не нужно. Вот, вообще не нужно.

И это так по человечески. Ведь,
когда я хочу позвать к себе в гости Марата, я делаю этоочень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена блинов нажарит, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову его отдельно, отдельно его жену и каждого ребенка в отдельности. Нет, только его,
а уж он сам приведеёт всё семейство, будьте уверены.

```javascript
{
    друг: 'Марат'
}
```

И с блоком так же. Когда я хочу, чтобы на станице появился какой-то блок, Я НЕ ХОЧУ думать, о том, из каких тегов и атрибутов он внутри устроен.

Ну, в самом деле, я когда в ресторан прихожу, и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша, в солянке должно быть четыре кусочка картошки, 50 граммов салями,
мелко нарезанный солёный огурчик..." Нет. Я просто заказываю солянку. Ну максимум, меня могут спросить: "Вам со сметаной?" Да, конечно, мне со сметаной:

```javascript
{
    суп: 'солянка',
    сметанаНужна: 'да'
}
```

То есть могут ещё задать какой-то дополнительный параметр. Командир в окопе кричит сержанту: "Сержант Петренко,
 прикрыть правый фланг!".

```javascript
{
    сержант: 'Петренко',
    прикрыть: 'правый фланг'
}
```
Всё! Командир приказал — Петренко сделал. И пусть Петренко сам решает, как это делать — то ли вести самому автоматный огонь
в указанном направлении, то ли гранатами точку подавлять, то ли других бойцов послать штурмом фланг занять. Командиру
какое дело до этих деталей вообще?

Ну что, похоже на правду?

```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

**Марат:** Пусть блоки сами решают, в какой html они должны превратиться, чтобы лучшим образом выполнить свою задачу.
Как они устроен внутри, я как пользователь блока, думать не хочу.

И за это я люблю Бивис. Создавать страницы из готовых блоков никогда не было ещё так просто.

####Блок - триединство структура-представление-поведение
Да и сами блоки создавать тоже просто, потому что это очень жизненная абстракция.

Как и во многих компонентных системах блок состоит из трёх составляющих
Во-первых это структура. Во-вторых, это представление. И в третьих, это поведение.

Структуру вы могли уже наблюдать. Это наш JSON. Который может быть древовидный.
Одни компоненты могут вкладываться в другие. Третьи компоненты могут иметь субкомпоненты
внутри себя и общаться с ними.

Представление - это наш любимый CSS, но вы его немного улучшили для своих целей.
Не без помощи готовых инструментов, об этом мы расскажем позже.

И поведение — это то, что связывает всё и делает интерактивной страницу и каждый блок по-отдельности
Здесь у нас тоже появилось несколько идей, которые мы реализовали. И о них мы тоже обязательно вам
расскажем.

Но начнём по порядку. Сначала Вадим расскажет вам про HTML-структуру.


##HTML-структура

### Императивные шаблоны

Как мы генерим html в смарти, джанго и других MVC-фреймворках?

Мы пишем шаблоны, которые выглядят, как html-код, в который точечно добавляются данные. Как будто шприцом обкалываем:
```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервиcный центр.</p<
{% endif %}
```

Эти шаблоны мы пишем вот в этом месте.

[слайд-схема с index.tpl.php]()

В бивисе мы решаем эту задачу с помощью декларативных шаблонов.

### Декларативные шаблоны

На `XSLT` писали? `XML` в `HTML` трансформировали? Тогда вы нас понимаете - шаблоны как в `XSLT`
А кто не писал на `XSL`, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это CSS-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

`CSS`-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо инъекций шприцем (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Это как горчичники - если есть куда их приложить - доктор их обязательно приложит.
Горчичники заматчатся или не заматчатся.

Предположим, наш контроллер выглядит так - на странице мы хотим видеть одну только шапка. Больше никаких блоков.

```javascript
pages.declare('index', function () {
    return {
        block: 'header'
    }
});
```

Мы хотим, чтобы из этого json-а на странице появился такой html:
```html
<div class="header"></div>
```

Декларативный шаблон мог бы выглядеть почти, как в CSS

```javascript
header {
    tag: div;
}
```

Этот шаблон бы читался так: если на странице объявлен блок header, вылей для него тег div.
В реальности, мы почти так и пишем, только на чистом валидном javascript:

Это шаблон на Бивисе:
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Похоже на это, правда?
```javascript
header {
    tag: div;
}
```
Мы матчимся по селектору, для которого выполняется функция.
А в функции сказано - создай тег `div`

Он довольно бесполезный. Чтобы вылить тег, столько всего написать надо.
Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок.

**Марат:** говорит...

Для начала мы добавляем элемент title, который будет загловком нашего блока.
Кроме того, мы передаём ему ещё какие-то данные, которые он должен отобразить.

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });
});
```

И теперь мы матчимся на элемент title.
Задеём ему тег и содеримое, которые мы ранее передали через параметр.

```javascript
// регистрируем матчер для элемента title блока header
bt.match('header__title', function (ctx) {
    ctx.setTag('h1');

    // задаём содержимое заголовку из параметра text
    ctx.setContent(
        ctx.getParam('text')
    );
});
```

И в результате мы получаем такой html
```html
<div class="header">
    <h1 class="header__title">CodeFest 2014</h1>
</div>
```

Но это всё синтетический пример. Давайте посмотрим на реальный пример ихз Яндекса.

Это настоящее описание шапки, которое мы используем в Яндекс.Картах.

Единственное обязательное поле в этом JSON - это имя блока.
Все остальные поля - они необязательны, и блок `header` будет работать, даже если они все не указаны.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Вот так это всё выглядит в браузере:

[живое демо]

#### Это оверхед?
**Вадим:** Марат, это не кажется нам оверхедом? Императивные шаблоны Смарти и Джанго привычные, понятные, их понимают все.
Почему мы не используем их?

**Марат:** Императивные шаблоны остаются понятными, пока их немного.
Когда проект разрастается, все больше и больше визуальных фрагментов переиспользуются,
то и шаблоны становятся сложными и запутанными.

В такой ситуации BT-шаблоны позволяют сохранять сложность на одном уровне.
Более того, BT-шаблоны позволяют нам иметь явный и понятный API каждого фрагмента страницы.
BTJson блока - это его внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на примере.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.
```html
<div>тут сложный некрасивый html</div>
```

Но самое ценное, что теперь можно как угодно менять шаблон, который генерирует html.
Но вызов блока, его АПИ остаются такими же. Нам не нужно переписывать страницу,
которая использует этот блок. Или другие блоки, которые его используют.

И мы можем не бояться, что что-то пойдёт не так. Потому что именно соблюдение АПИ как и гарантируют нам результат.

Возможно, кто из вас читал про Web Components.

Бивис реализует именно эту же идею. Но отличие в том, что Web Components пока ещё не поддерживаются браузерами, а бивис вы можете использовать уже сегодня.

Вадим, расскажи про представление в бивис-блоках.

## CSS блока

**Вадим:** Имя у блока может быть простым — просто Марат, или просто Вадим, или просто header. Но бывают случаи, когда оно должно быть более точным.
Например, Марат Дулин, или Вадим Макишвили. Чтобы добавить в имя уникальности.

Кого из вас зовут Вадим?

Представьте, вбегает сейчас в зал (вон в ту дверь) организатор конференции и кричит: "Эй, Вадим, в продакшене 404 ошибка на главной странице!".
Сколько Вадимов встрепенётся и занервничает? Да, все Вадимы. Но если он крикнет "Вадим Макишвили", то встрепенусь только я.

Жизнь доказывает, что имени и фамилии достаточно для идентификации человека.

Когда мы зовём block: 'header', мы зовём наш блок по имени. Но если мы хотим добавить ещё больше уникальности, мы добавляем здесь
же "фамилию", которую у блока мы именуем словом `view`

```javascript
{
    block: 'header',
    view: 'search'
}
```

Читать это следует так: создай на странице шапку, да не простую, а поисковую.
Получится такой HTML:

```html
<div class="header_search">
    ....
</div>
```

Понимаете, блок один - шапка, но на одной странице она может быть поисковая, а на другой непоисковая.
Поэтому у неё есть два варианта отображения на странице, два представления, две темы, два скина, две шкурки...
два `View`. Разный вид одного и того же блока мы называем разным преставлением. Разным `View`.

Это вью активно используем когда пишем стили.

Теперь мы сделаем важное завяление, с которым кто-то из вас будет категорически несогласен.
Но тем интереснее, да? :)

Мы убеждены, что имя у блока должно быть одно. Мы не согласны с теми из вас, кто использует в верстке такой приём:

```
<div class="header authorization"></div>
```

Что это - шапка и форма авторизации одновременно? Это как? Я и папа, я и мама? Вы смотрели фильм Георгия Данелия "Мимино"?
Мимино - это главный герой - грузинский летчик из горного села. Играет Вахтанг Кикабидзе.
По сценарию Мимино прилетает в Москву, найти работу в большой авиации. Жить ему негде, в гостиницах мест нет.
Но знакомые знакомых договорились по блату поселить его в гостиницу, в которой как раз проводится всесоюзный слёт врачей-эндокринологов.
И чтобы Мимино заселили, ему нужно было на ресепшине солгать, что он тоже врач-эндокринолог.

И вот представьте. Мимино приходит в гостиницу. Синяя отутюженная форма лётчика. Погоны. Фуражка с эмблемой авиации.
И когда его удивлённо спрашивают "Вы, что — лётчик?", знаете, что он отвечает?

— Да. Иногда. Но, вообще-то, я эндокринолог.

Хороший летчик не может быть одновременно хорошим эндокринологом. Попробуй совмещать обе профессии - это же сплошные проблемы,
такова жизнь, не нам с ней спорить.


И в верстке с множественными именами сплошные проблемы. Хаос и боль, потому что в CSS есть грандиозная проблема для больших веб-сайтов:

В `CSS` нет надёжного механизма разруливания весов стилевых селекторов с одинаковой специфичностью. Какой селектор позже записан, тот и применится к тегу.

В `BEViS` мы отказались от смешивания блоков друг с другом. Нет миксов блоков на одной ноде - нет конфликтов.

**Марат:**
Не знаю, как у вас в проектах, у нас в Яндексе довольно часто можно встретить такие записи:
```html
<div class="button button_theme_normal button_shadow_yes">кнопка</div>
```

Есть некий базовый класс и несколько модификаторов, каждый добавляет к базовому классу что-то или переопределяет
какие-то стили из базового класса.

Чем это опасно?
Вы добавляете или изменяете какое-то свойство в одном из этих трёх классов, у вас нет никакой гарантии, что
ваши исправления не придут в конфликт весов со стилями других классов на этой ноде.

В большом проекте даже после небольших изменений в таких стилях хорошо бы перетестировать весь проект с нуля,
чтобы убедиться, что верстка не сломалась в тех блоках, где есть множественные классы. Проблема же в том, нет
другого механизма, кроме ручного пребора каждой страницы.

И это совсем не похоже на независимые блоки. Какая же это независимость, если даже внутри одного блока могут
родиться проблемы отображения? Трудно себе даже представить потенциальные конфликты в стилях, если мы смешаем
два разных блока на одной ноде.

Что делает Бивис?
Мы в такой ситуации рассуждаем так. Одна нода - один блок. Если в проекте нужна кнопка с темой нормал и тенью, то должен существовать отдельный класс,
в котором сразу будет и тема нормал и тень. В одном классе. Поэтому та запись с тремя классами превращается в один класс:

```html
<div class="button_normal-shadow">кнопка</div>
```

То есть мы делам блок button с view = normal-shadow. В json это записывается нами так:

```javascript
{
    block: 'button',
    view: 'normal-shadow'
}
```

**Вадим:** А как мне отобразить эту же кнопку, но в нажатом состянии? Ещё один вью писать?

**Марат:** Нет, не нужно. Есть состояния.

**Марат:** Мы делаем это с помощью препроцессора.

**Вадим:**
Кто сейчас не знает, что такое препроцессор? Все знают.

[схема что такое препроцесор]()


Кроме меня. Я относился к CSS-препроцессорам брезгливо. "Баловсто это", — я так считал, — "Тот же CSS, только с синтаксическим сахаром."
А сахар я не люблю, кофе могу пить и несладкий.

Только оказалось, что сахар в препроцессорах - это не то, ради чего они нужны.
Мы с их помощью делаем верстку гибкой и модульной.

Как мы решаем задачу?

```css
skin-common() {
    /* общие стили для кнопки */
}

skin-theme-normal() {
    /* цветовая тема */
}

skin-shadow() {
    /* стили добавляют тень */
}

.button {
    skin-common()
    skin-theme-normal()
}

.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();
}
```

`skin-common()`, `skin-theme-normal()`, `skin-shadow()` - это так называемые миксины, примеси по-русски. Те же `javascript`-функции.

Мощь в том, что эти функции приватны. Они не попадают напрямую в скомпилироанный css-файл. Пока из конкретного селектора не вызову этот миксин, его содержимое нигде не светится
Я создаю селектор для нормальной кнопки с тенью, явно вставляю в него вызов нужных миксинов. Если между стилями вознкли какие-то конфоликты,
я их здесь же (всё ещё на сервере) разрузлил, и в браузер пойдёт css-селетор, в котором полный порядок.

Мы можем решить конфликты на этапе разработки, а не на этапе использования
В браузер пойдёт для этого блока один css-селектор. Гарантированно работающий.

```css
.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();

    /* а здесь разрулил все конфликты этих миксинов */
}
```

Идею так использовать препроцессор мы позаимствовали у Романа Комарова. Он предложил такую же схему для своего CSS-фреймворка Stylobat. Рома - это тот парень,
который является сейчас мейнтейнером препроцессора Stylus. Гениальный верстальщик, добрый человек. Рома, спасибо тебе большое!

## JS-поведение блока
**Марат:** Как мы пишем js для блоков на странице?

В маленьких проектах мы делаем так:

```javascript
$( document ).ready(function() {

    var form = $('#my-form');
    form.submit(onSubmited);

    function onSubmited() {
        if ($('#my-form .button').hasClass('disabled')) {
            return false;
        }
    }

});
```

Для каждого блока мы описываем, что он должен делать.
Здесь же описываем реакции на пользовательские события.

В бивисе мы делаем то же самое, только не внутри ```$( document ).ready()```, а внутри модуля.

У нас есть своя модульная система, она асинхронная на всех этапах своей работы.
Примерно так выглядит описание модуля в терминах модульной системы.

То есть, тот же код, что на предыдущем слайде, только лишённый глобального экспорта.

```javascript
modules.define(
    'form',
    ['jquery'],
    function(provide, $) {

        var form = $('#my-form');
        form.submit(onSubmited);

        function onSubmited() {
            if ($('#my-form .button').hasClass('disabled')) {
                return false;
            }
        }

        provide(form);
    }
);
```
Сам код остался тем же, обвязка немного поменялась.

Мы объявили модуль в первой строке.
Во второй мы далеи модулю имя.
В третьей  описали зависимости — в нашем случае это только JQuery

И мы описали то, из чего состит модуль. То есть то, что этот модуль экспортирует.

**Вадим:** А внутри модулей мы используем голый jQuery?

**Марат:** Да нет, на самом деле мы не используем напрямую JQuery.
Мы используем свой базовый класс для написания блоков.

Этот класс даёт нам возможность описывать блок в виде абстракции над DOM-деревом.
И более того, мы не используем JQuery и в процессе написания самого блока, а не только использования.

```javascript
modules.define(
    'form',
    ['button', 'input', 'y-block'],
    function(provide, button, input, YBlock) {

        var Form = inherit(YBlock, {
            __constructor: function () {
                this._submitButton = YButton.find(this);
                this._bindTo(this.getDomNode(), 'submit', this._onSubmited);

            },

            _onSubmited: function (e) {
                if (this._submitButton.isDisabled()) {
                    e.preventDefault();
                } else {
                    this.emit('submit');
                }
            }
        });

        provide(Form);
    }
);
```

**Вадим:** Зачем оно такое надо? Модули и свой js-класс для блоков? Почему не просто jQuery?

**Марат:** Во-первых, мы получаем код, который можно вновь и вновь использовать.
А во-вторых — абстракцию над HTML-структурой блока. Нам не важно, как блок представлен на странице.
Порой нам даже не важно, где он лежит - в body или в каком-то другом элементе.

Мы переходим от DOM-взгляда на компонент на другой. Мы смотрим на блоки с точки зрения семантики их работы.

**Вадим:** Да. А ещё это нужно, чтобы максимально разделить визуальное отображение и поведение. У Бивиса получилось.

Когда бивис сгенерит html для шапки, вы увидите там такое:
```html
<div
    class="header"
    data-block="header">
</div>
```
Слово `header`, записанное в атрибуте class участвует исключительно в стилях.
А то, что написано в `data-block` - именно по этому атрибуту Бивис находит шапку и назначает ей js-поведение.

В бивисе блок может иметь один css-класс, а дата-атрибут совершенно другой. То есть вы можете спокойно удалить атрибут -
поведение вы потеряете, но внешний вид блока не сломается.

Едиственное место, где поведение и отображение пересекаются, это состояния блока. Этого никак не избежать, потому что и в жизни оно так устроено.

Когда я бегаю по стадиону, я краснею и потею. Меняется мой внешний вид. Когда я плаваю долго в море, кожа на пальцах сморщивается и бледнеет.

В блоке тоже самое. Например, возьмём ту же форму авторизации. По нажатию на кнопку сабмита надо проверить поле логина. Если пустое - обвести поле логина стыдливой красной рамкой. То есть изменить отображение блока, сменить его состояние с обычного на тревожное.

Из `js` мы добавляем дополнительный класс, который отвечает за изменение внешнего вида в состоянии "тревога".

Вот что произойдёт в html-элемнте блока
```html
<input class="login _unfilled" type="text"/>
```

а вот что мы заранее напишем в стилях
```css
/* обычное состояние */
.login {
    ...
}

/* тревожное состояние */
.login._unfilled {
    border: 1px solid red;
}
```

И когда мы на клиенте проверим, что поле логина пустое, мы добавим в ноду к инпуту класс "_unfilled"
Мы называем такие классы состояниями: State.
Имя стейта может быть любым, какое вы выберете. Вам всего лишь нужно в стилях предусмотреть, что
если js добавит такой-то стейт-класс, чтобы в отображении что-то изменилось.

Почему класс начинается с подчёркивания? Чтобы подчернуть, что он приватный для блока и чтобы легче его замечать.

Теперь понимаете, почему мы назвали наш подход BEViS?
```
B — [B]lock
E — [E]lement
Vi— [Vi]ew
S — [S]tate
```

## Сборка статики без боли

Мы почти закончили. Марат, расскажи нам, как блок представлен на файловой системе.

**Марат:** Конечно же мы не пишем все стили в одном файле, все шаблоны в одном файле, весь клинетский js в одном файле.
Каждый блок представлен на файловой системе своей папкой, это удобно и очень по-человечески.

Ведь у меня, как и у любого человека, есть дом — место, откуда я выхожу утром на работу и куда возвращаюсь каждый вечер.
Ну, хорошо, это не дом. Это квартира в многоэтажке.

У блока тоже есть свой дом - место, где блок отдыхает и ждёт, когда его "позовут поработать" в веб-странице.
В корне проекта есть директория `/blocks`, в ней живут все блоки. Только в ней. Это дом блоков. Не ищите других мест.
Если блока здесь нет, больше нет нигде.

````
/blocks
    /header
        header.bt.js
        header.styl
        header.js
    /form
        form.bt.js
        form.styl
        form.js
````

Каждый блок хранится в своей собственной папке, где шаблоны для генерации html описаны в `bt.js`, стили в `styl`, клиентский яваскрипт в `js`.

**Вадим:** Эффективно, хотя и не ново. Когда моя дочка готовится к математике, она на парту выкладывает учебник по математике, тетрадь по математике, угольник и карандаш — всё, что нужно именно для урока математики. У нас так же - всё, что нужно для блока находится в одной папке.

А когда учительница хочет проверить у всего класса домашнюю работу, она ходит по рядам и забирает тетради в стопку.
У нас тоже есть такой сборщик. Когда в сервер приходит запрос на страницу, соирается не только html, но и css, и js. Это всё делает сборщик. Почему не Ant, Make, Grunt?

Марат, зачем ты сделал [ENB](https://github.com/enb-make/enb)?

**Марат:** Наш сборщик отличается огромной скоростью сборки для проектов с блочной структурой. И в нём есть встроенный сервер, он автоматически отслеживает изменения на фаловой системе и пересобирает файлы.

Сборка часто являлась узким местом в сложных компонентных системах, но в рамках BEViS мы полностью интегрировали сборку в процесс разработки. Работая над проектом достаточно лишь обновлять страницу в браузере, чтобы всегда видеть актуальные стили, скрипты и верстку. 

**Вадим:** А ещё у твоего сборщика очень понятная документация и робот-конфигуратор, с помощью которого создавать конфиг для сборщика сможет школьник.


## Заключение

**Вадим:** [Документация](http://github.com/bevis-ui/docs) у бивиса прекрасная — достаточная и понятная.
Мы писали её для живых людей.

Начать работать на бивисе тоже очень просто:

```
git clone git@github.com:bevis-ui/bevis-stub.git your-project
cd your-project
make
```

После этого мы открываем в браузере ```localhost:8000``` и говорим: "Привет, Бивис!"

**Марат:** Кроме того, мы реализовали страницу в стиле TodoMVC на Бивисе. *Перещелкиваю слайд.* http://github.com/bevis-ui/bevis-todo. Можно сравнить Бивис с другими MVC и компонентными фреймворками.

**Вадим:** Пользоваться бивисом одно удовольствие, потому что 99% бивиса - это обычный javascript.
Весь этот код покрыт юнит-тестами. Он написан в очень понятном кодстайле, которым придерживается
команда Яндекс.Карт.

Мы не просим становиться нашими контрибьюторами, потому что особо нечего контрибьютить. Ведь наши
инструменты работают хорошо, а бивис-подход вполне жизнеспособный, мы доказали это на нескольких проектах.
Например `beta.maps.yandex.ru` сделан на бивисе.

Мы осознаём, что верстать на бивисе маленький сайтик — это все равно что экскаватором пытаться выкопать
лунку для гольфа — вместо лунки вы получите яму для саженца. Но если вдруг вам нужно перекопать
большое поле и вы хотите быть уверены, что в процессе копания не повредите
какие-то важные подземные коммуникации, тогда бивис - и для вас тоже.

**Марат:** С вами была команда Яндекс.Карт и её представители на этой конференции - Вадим Макишвили и Марат Дулин. Спасибо вам большое за внимание!
