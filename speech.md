Привет, "Вадим Макишвили — это я" (с)

Я прилетел к вам с юга Украины, из Симферополя. Сейчас там тепло и солнечно. А у вас холодно и снег. Я у вас замёрз.
Мне никто не сказал, что здесь будет так холодно. :)

Но главное, что здесь, на конеференции, очень тепло, уютно и по-домашнему. Вы - прекрасны. Организаторы - чудесны. Спасибо вам большое, что позвали!

Я прилетел к вам не только для того, чтобы рассказать про Бивис, который мы придумали в Яндекс.Картах.
Текст этого доклада уже есть на гитхабе в виде статьи, ей можно прочитать хоть сейчас.

В первую очередь я хочу познакомить вас вас с необыкновенным человеком.

С человеком, который доказывает, что можно быть гениальным программистом и не быть занудой.

С человеком, который умеет не только писать качественный код, но писать документацию к коды.
Такую документацию, которую будет интересно читать живым людям.

С человеком, продукты которого набирают популярность и внутри и снаружи Яндекса.
И такие проекты, как jquery, bootstrap и angularjs, уже используют один из продуктов этого человека.

Итак, я с огромным удовольствием представляю вам моего хорошего друга и талантливейшего программиста — Марата Дулина!

**Марат:** Привет. Бивис - это фулстек-фреймфорк, на котром можно сделать большой надёжный сайт.
Сейчас есть уже подобные решения, каждое со своими плюсами и минусами, у каждого свой порог сложности.
Наше решение очень простое. Сделать сайта на бивисе способен даже школьник, потому что школьнику нужно знать только html/css/js.
Об этом мы хотим рассказать сегодня.


**Вадим:** Мы вам чстно признаемся, у нас нет никаких целей на этой презентации.
Мы не ищем контрибьюторов. Потому что особо контрибьютить у нас нечего.
Мы не говорим, что принесли вам новую веб-религию и вам срочно нужно бросать
свои велосипеды и пересаживаться на наш. Мы по-братски поделимся с вами своими придумками. Больше никаких целей - ни явных, ни скрытых.

Ну, что поехали? Ты готов, Марат? И я готов. Тогда начали!

Когда-то я программировал на PHP. Я тогда использовал Смарти-шаблонизатор. Возможно, вы когда-то писали на Python, использовали Джанго.
Что такое обычное MVC-приложение?

[Слайд](http://makishvili.github.io/bevis/index.html?full#2)

1. Запрос из браузера попадает на какой-то http-сервер. Это может быть Apache, может быть Nginx. Это совершенно не важно

2. Дальше запрос направляется в контроллер - программу, написанную, например, на PHP или на Python.
Контроллер выполняет две простых задачи - получить данные из бекенда (или напрямую из базы данных) и передать данные в шаблоны представления

3. Шаблоны сегенерят html, и ответ уйдёт назад в браузер.

Эта схема знакома каждому из нас. Так? Ну, так бивис работает по этой же схеме.

----
3 минуты 30 секунд

----

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

1. Вместо Apache или Nginx у нас Node.js.
2. Вместо `php`-страничек мы пишем контроллер на серверном `js`. Он ходит куда-то за данными и отдаёт в шаблоны.
3. Шаблоны, тоже написанные на серверном `js`, генерят `html`, и ответ уходит в браузер.

Давайте посмотрим внутрь бивис-контролера. Что там, Марат?

```javascript
module.exports = function (pages) {

    pages.declare('index-page', function (params) {
        return {
            block: 'page',
            styles: 'index.css',
            scripts: 'index.js'

            body: [
                {
                    block: 'header'
                },
                {
                    block: 'authorization',
                    actionUrl: '/?task=login'
                }
            ]
        };
    });

};
```

**Марат:** Так как мы пишем на `Node.js`, наш яваскрипт завернут в `Node.js` модули. Если вы на `Node.js` не писали, не пугайтесь.
Не обращайте внимания на первую строку. Относитесь к ней, как обвязке, без которой нельзя. Всё интересное происходит внутри.
А внутри обычный `javascript`. Видите вызов функции `page.declare()`?

В бивис-приложении есть объект `pages`, у которого есть метод `declare`.
Выражаясь языком юристов, это "декларация о намерениях". Мы декларируем, что наша страница будет состоять из
нескольких компонентов и перечисляем  эти компоненты в каком-то простом формате.

Мы сказали, что страница состоит из блока `page`, в теле которого есть два других блока - `шапка` и `форма авторизации`.
Это абсолютно валидный `JSON`. Совершенно обычный `JSON`. Бивис создавался, как фреймворк, который использует совершенно валидные нативные конструкции.

**Вадим:** `JSON`? Почему `JSON`? Почему нет `HTML`-тегов? Но я и сам знаю ответ на этот вопрос.

Если посмотреть на любую картину вблизи - это же хаос - цветные мазочки-мазочки-мазочки. Ни черта не разобрать.

[ утро в сосновом бору zoom x 10]()

А если отойти от картины - О, так это де Шишкин Иван Иванович с его знаменитиыми мишками.

[ утро в сосновом бору zoom x 1]()

Ну, в самом деле, когда мы получаем эскиз сайта от дизайнера, мы смотрим на него и
видим не теги, которые будет в html-файле. Мы видим какие-то абстрактные блоки. Ага - это будет шапка, это подвал,
тут форма авторизации, а здесь меню. Кто-то называет это компонентами, модулями, контролами. В Яндексе это называют блоками.
Как Виталий Харисов в 2006 году произнёс это слово в докладе про верстку
независимыми блоками, так оно у нас в обиходе и осталось. Ну и пусть.

Бивис-блок - это очень прастая декларация на JSON. Простота - это очень важно.
Чем предмет проще, тем легче им пользоваться. Тем больше удовольствия от использования.

Бабушка моей жены любит печь хлеб сама. Мы подарили ей хлебопечку. Казалось бы - насыпь муки, дрожжей,
налей воды и масла и нажми пару кнопок - очень просто. Но бабушка Дуся не пользуется. Она не может запомнить
в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Она по-прежнему пользуется газовой духовкой - куда проще - поджечь комфорку, сунуть противень внутрь, закрыть дверцу.

Какой веб-фреймворк для верстки ни возьми, он в какой-то степени напоминает злебопечку. Или пульт от навороченного телевизора.
Пожилым людям из всего пульта нужно три кнопки: включить, сделать громче и переключить канал.

Мы с Маратом люди пожилые. И в отделе у нас работают ребята, которым уже за тридцать, а кому-то и под сорок, как мне :)
Нам надоело описывать страницу тегами, размечать их атрибутами - это неоправданно сложно. Слишком много суеты, слишком мало смысла.

Вот простое описание страницы.
```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Здесь сказано, что на странице будет два блока - шапка и форма авторзации. Здесь нет ни одного тега, ни одного атрибута.
Но такого описания достаточно, чтобы Бивис сгенерил полноценный развесистый html, например такой:

```
<div class="header">
    <a class="header__logo" href="/"><img src="logo.png" /></a>

    <h1 class="header__title">Демо-страница</h1>

    <a class="header__rss" href="/?rss"><img src="rss.png" /></a>
</div>

<form class="authorization" action="/?task=login">
    <input class="authorization__login" value=""/>
    <button class="authorization__submit"/>
</form>
```

####Чтобы пользоваться блоком, достаточно одного имени

И мы в Бивисе сделали одну крутую вещь, которой гордимся-гордимся.

Чтобы на странице появился блок, его достаточно позвать на странице только по имени. Всё, больше о нём мне ничего знать не нужно. Вот, вообще не нужно.

И это так по человечески. Ведь,
когда я хочу позвать к себе в гости Марата, я делаю этоочень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена яблочный пирог испечёт, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову его отдельно, отдельно его жену и каждого ребенка в отдельности. Нет, только его,
а уж он сам приведеёт всё семейство, будьте уверены.

```javascript
{
    друг: 'Марат'
}
```

И с блоком так же. Когда я хочу, чтобы на станице появился какой-то блок, Я НЕ ХОЧУ думать, о том, из каких тегов и атрибутов он внутри устроен.
Я зову его просто по имени. Ну и если надо сообщаю блоку какую-то дополнительную информацию. Командир в окопе кричит сержанту: "Сержант Петренко,
 прикрыть правый фланг!".

```javascript
{
    сержант: 'Петренко',
    прикрыть: 'правый фланг'
}
```
Всё! Командир приказал — Петренко сделал. И пусть Петренко сам решает, как это делать — то ли вести самому автоматный огонь
в указанном направлении, то ли гранатами точку подавлять, то ли других бойцов послать штурмом фланг занять. Командиру
какое дело до этих деталей вообще?

Ну что, похоже на правду?

```javascript
[
    {
        block: 'header'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Пусть блоки сами решают, в какой html они должны превратиться, чтобы лучшим образом выполнить свою задачу.
Как они устроен внутри, я как пользователь блока, думать не хочу.

Ну, в самом деле, я когда в ресторан прихожу, и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша,
нагрей суп в кастрюле, потом налей два половника в глубокую тарелку,
насыпь сверху зелени и сметаны ложку и только после этого неси мне." Нет, я просто говорю: "Мне солянку". Я точно
знаю, что в кафе солянка уже сварена, её сейчас мне подадут.

И с шапкой так же: "Мне шапку!"

```javascript
{
    block: 'header'
}
```

И за это я люблю Бивис. Создавать страницы из готовых блоков никогда не было ещё так просто.

####Блок - триединство структура-представление-поведение

Вы замечали, что любое изобретение человека может существовать только тогда, когда оно не противоречит законам природы?
Квадратное колесо не прижилось, хотя человек пытался наладить его промышленный выпуск. А чё? Его легче производить,
легче транспортировать к точкам продажи, легче устанавливать. Но квадратное не может катиться.
Это закон физической природы. Против него идти глупо.

Всё, что создано человеком и смогло сохраниться веками - это то, что следует законам природы, а не противоречит.

Блок - это очень жизненная абстракция. Блок, как божья тварь, состоит из трёх Начал.
Чтобы было понятнее, представьте меня в виде модуля, в виде блока:

1. У меня есть скелет, мышцы и внутренние органы. Это моя структура. У блока эту роль выполянет HTML-разметка.
2. У меня есть какой-то рост, вес, цвет кожи и выражение лица. Это мой внешний вид. У блока эту роль выполняют CSS-стили.
3. Я сейчас размахиваю руками и говорю с вами со сцены. Это моё поведение. Блок тоже умеет как-то взаимодействовать с пользователем на странице.

Природа создала человека - очень сложный модуль, со сложным внутренним строением, с разнообразным внешним видом,
с самым непредсказуемым поведением. А человек подглядел это решение, и по образу и подобию научился делать блоки для веб-страниц.

Мы такую красивую аналогию вам привели, когда вы в ресторане солянку заказали. Эффектно, да?
Но в жизни мы в рестоарны редко ходим. Обычно я ужинаю дома. И если я попробую дома сказать жене: "Хочу на
ужин борщ с фасолью, и сметаной", а потом на диван сяду и в iPad уткнусь, ожидая, что через пару минут
передо мной окажется тарелка ароматного борща, знаете, что я услышу в ответ?

— Легко! Картошку почисть!

Да, такова жизнь. Жёнам нужно помогать. Это аксиома.

Когда вы начинаете разрабатывать сайт и глядя на эскиз,
представляете из каких блоков построите страницу, вы описываете сайт на уровне абстракций. Но ведь потом
вам придётся длоя этих абстракций сгенерить нужный html, нужные стили и клиентский javascipt, потому что браузеры
понимают только эти технологии. И никто кроме вас этого не сделает.

##HTML-структура

### Императивные шаблоны

Как мы генерим html в смарти, джанго и других MVC-фреймворках?

Мы пишем шаблоны, которые выглядят, как html-код, в который точечно добавляются данные. Как будто шприцом обкалываем:
```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервиcный центр.</p<
{% endif %}
```

Эти шаблоны мы пишем вот в этом месте.

[слайд-схема с index.tpl.php]()

В бивисе мы решаем эту задачу с помощью декларативных шаблонов.

### Декларативные шаблоны

На `XSLT` писали? `XML` в `HTML` трансформировали? Тогда вы нас понимаете - шаблоны как в `XSLT`
А кто не писал на `XSL`, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это CSS-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

`CSS`-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо инъекций шприцем (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Это как горчичники - если есть куда их приложить - доктор их обязательно приложит.
Горчичники заматчатся или не заматчатся.

Вспомним нашу схему.

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

Браузер запрашивает страницу, сервер обрабатывает ваш запрос, создаёт декларацию страницы в формате `btjson`

Предположим, наш контроллер выглядит так - на странице мы хотим видеть одну только шапка. Больше никаких блоков.

```javascript
module.exports = function (pages) {

    pages.declare('index-page', function (params) {
        return {
            block: 'header'
        }
    });
};
```

Фактически, мы видим декларацию только одного блока. Не смотрите на всю мишуру вокруг, сконцентрируйтесь только на этом json:

```javascript
{
    block: 'header'
}
```

Мы хотим, чтобы из этого json-а на странице появился такой html:
```html
<div class="header"></div>
```

Декларативный шаблон мог бы выглядеть почти, как в CSS

```javascript
header {
    setTag: div;
}
```

Этот шаблон бы читался так: если на странице объявлен блок header, вылей для него тег div.
В реальности, мы почти так и пишем, только на чистом валидном javascript:

Это шаблон на Бивисе:
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Похоже на это, правда?
```javascript
header {
    setTag: div;
}
```

Шаблон записывается в виде функции `match`, в которую мы первым параметром передаём имя блока.
А вторым аргументом пишем функцию, внутрь которой приходит исходный `btjson` в переменной `ctx`
А в функции сказано - создай тег `div`

Функция `match` - это метод шаблонизатора `bt`. `BT` - это и есть повар в ресторане или ваша жена на кухне.
У шаблонизатора прекрасная документация, которую поймёт даже школьник, почитайте.

Так что же такое "матчинг", наложение шаблонов?

В CSS вы такой шаблон знаете под именем "селектор" (от английского to select), потому что селектор как бы
выбирает блоки, к которым нужно применить стилевые свойства, а в других декларативных языках эта же
декларация зовётся "шаблоном" (трудно сказать почему). И ещё говорят, что шаблон матчится на
блок (от английского to match, что переводится, как "подбирать", "приводить в соответствие").
Кстати to select имеет те же самые значения, что и to match. То есть это равнозначные слова с одинаковым смыслом :)

Матчинг - это и есть селекция, выбор, проверка совпадения условий в селекторе (матчере).
То же самое, что вы делаете, когда пишете CSS-стили.

Только эти шаблоны вы пишете не в css-файле, а в index.bt.js.
Посмотрите ещё раз на схему, чтобы соориентироваться.
В SMARTy шаблоны хранятся в `index.tpl.php`, а у нас в `index.bt.js`

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

А теперь вернёмся к шаблону
```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
});
```

Он довольно бесполезный. Чтобы вылить тег, столько всего написать надо.
Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок.

Я добавил комментарии в код, чтобы вы всё поняли, а я помолчу.

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });
});

// регистрируем матчер для элемента title блока header
bt.match('header__title', function (ctx) {
    ctx.setTag('h1');

    // Получаем параметр text
    var text = ctx.getParam('text');

    // задаём содержимое заголовку
    ctx.setContent(text);
});
```

Результат:
```html
<div class="header">
    <h1 class="header__title">CodeFest 2014</h1>
</div>
```

А теперь сделаем шапку настраиваемой - чтобы можно было задавать текст заголовка на жестко, а гибко.
Предполагаю, что имя заголовка нам придёт из базы и контроллер создаст `btjson` с параметром блока, назовём его `text`
Давайте сходим в базу за текстом заголовка:

```javascript
var http = require('http'); // подключили Nodejs-модуль для http-запросов

module.exports = function (pages) {

    var headerTitle = http.get(...); // здесь сходили в базу и получили ответ

    pages.declare('index-page', function (params) {
        return {
            block: 'header'
            text: headerTitle // здесь подставили значение из базы
        }
    });

};
```

Изменим одну строку в шаблоне — будем принимать значение параметра:

```javascript
bt.match('header', function (ctx) {
    ctx.setTag('div');
    ctx.setContent({
        elem: 'title',
        text: ctx.getParam('text') // получаем значение из параметра
    });
});


bt.match('header__title', function (ctx) {
    ctx.setTag('h1');
    var text = ctx.getParam('text');
    ctx.setContent(text);
});
```

Наш результат — из базы пришёл свежий твит про наше вступление:

```html
<div class="header">
    <h1 class="header__title">twitter: Парни из Яндекса рассказывают про BEViS на #codefest. Приколисты!</h1>
</div>
```

Но это всё синтетические примеры. Посмотрим на реальный пример их Яндекса. Это описание шапки.
В нём одно обязательно поле - имя блока, остальные поля - это необязательные параметры, опции:

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Так оно выглядит в браузере:

[живое демо]

#### Это оверхед?
Марат, это не кажется тебе оверхедом? Императивные шаблоны Смарти и Джанго привычные, понятные, их понимают все.
Почему мы не используем их?

**Марат:** А как смарти-шаблоны обеспечивают реюзабельность одних и тех же блоков на разных страницах? Как эти шаблоны гарантируют стабильную верстку?
Никак. Когда вы захотите заменить верстку какого-то блока с дивов на табличку, вам придётся сделать это во всех Смарти-шаблонах, где этот блок уже описан.
И попробуйте сказать, что ни разу при этом не ошибётесь. Мы не поверим :)

Наш подход хорош тем, что на старнице нет описания того, КАК должен выглядеть блок, а только само указание, что "здесь есть такой-то блок и
у него такие-то параметры". Это же прям как в настоящем программированнии - вызов класса с передачей в него параметров.
Класс выставляет наружу интерфейсные методы, которые не меняются и поддерживаются пожизненно, а внутрення реализация класса скрыта от глаз,
находится в приватной области.

Мы создали то же самое для html-верстки.

BTJson блока - это внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на примере. При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Но самое ценное в том, что отныне можете менять шаблоны, генерирующие html как угодно часто, вам не нужно при этом переписывать
все страницы. И не бояться, что на какой-то странице что-то пойдёт не так. АПИ блока гарантирует результат.

Кто из вас читал про Web Components?
Бивис реализует ровно эту же идею, которая лежит в основе развивающихся Web Components: семантика отдельно, теневое дерево отдельно.
Только веб-компоненты пока нельзя использовать для продакшена, а бивис уже можно ;)


## CSS блока

**Вадим:** Имя у блока может быть простым — просто Марат, или просто Вадим, или просто header. Но бывают случаи, когда оно должно быть более точным.
Например, Марат Дулин, или Вадим Макишвили. Чтобы добавить в имя уникальности.

Кого из вас зовут Вадим?

Представьте, вбегает сейчас в зал (вон в ту дверь) организатор конференции и кричит: "Эй, Вадим, в продакшене 404 ошибка на главной странице!".
Сколько Вадимов встрепенётся и занервничает? Да, все Вадимы. Но если он крикнет "Вадим Макишвили", то встрепенусь только я.

Жизнь доказывает, что имени и фамилии достаточно для идентификации человека.

Когда мы зовём block: 'header', мы зовём наш блок по имени. Но если мы хотим добавить ещё больше уникальности, мы добавляем здесь
же "фамилию", которую у блока мы именуем словом `view`

```javascript
{
    block: 'header',
    view: 'search'
}
```

Читать это следует так: создай на странице шапку, да не простую, а поисковую.
Получится такой HTML:

```html
<div class="header_search">
    ....
</div>
```

Понимаете, блок один - шапка, но на одной странице она может быть поисковая, а на другой непоисковая.
Поэтому у неё есть два варианта отображения на странице, два представления, две темы, два скина, две шкурки...
два `View`. Разный вид одного и того же блока мы называем разным преставлением. Разным `View`.

Это вью активно используем когда пишем стили.

Теперь мы сделаем важное завяление, с которым кто-то из вас будет категорически несогласен.
Но тем интереснее, да? :)

Мы убеждены, что имя у блока должно быть одно. Мы не согласны с теми из вас, кто использует в верстке такой приём:

```
<div class="header authorization"></div>
```

Что это - шапка и форма авторизации одновременно? Это как? Я и папа, я и мама? Вы смотрели фильм Георгия Данелия "Мимино"?
Мимино - это главный герой - грузинский летчик из горного села. Играет Вахтанг Кикабидзе.
По сценарию Мимино прилетает в Москву, найти работу в большой авиации. Жить ему негде, в гостиницах мест нет.
Но знакомые знакомых договорились по блату поселить его в гостиницу, в которой как раз проводится всесоюзный слёт врачей-эндокринологов.
И чтобы Мимино заселили, ему нужно было на ресепшине солгать, что он тоже врач-эндокринолог.

И вот представьте. Мимино приходит в гостиницу. Синяя отутюженная форма лётчика. Погоны. Фуражка с эмблемой авиации.
И когда его удивлённо спрашивают "Вы, что — лётчик?", знаете, что он отвечает?

— Да. Иногда. Но, вообще-то, я эндокринолог.

Это смешно? А вот это не смешно? Я и шапка и авторизация? Хороший летчик не может быть одновременно хорошим эндокринологом.
И наоборот тоже, кстати. Попробуй совмещать обе профессии - сплошные проблемы будут. Такова жизнь, не нам с ней спорить.

И в верстке с множественными именами сплошные проблемы. Хаос и боль, потому что в CSS есть грандиозная проблема для больших веб-сайтов:

В `CSS` нет надёжного механизма разруливания весов стилевых селекторов. Какой селектор позже записан, тот и применится к тегу.
В нашем случае, если в стилевом файле селектор `.header {border-color: red}` записан позже селектора `.authorization {border-color: green}`,
то блок окажется окружён красным бордером. А если вдруг селекторы придут в обратном порядке - вокруг блока будет зелёный бордер.
А приходить они могут в разной последовательности, когда у вас динамическое построение `CSS`-файла.

Когда мы смешиваем два блока на одной `HTML`-ноде, нет способа влиять на эту ситуацию, нет возможности контролировать её.
Управлять ей. Точнее, он есть, но он вообще не гарантирует результат — надо загружать стилевые селекторы в "правильном" порядке,
собирать `CSS`-файл в "правильном" порядке.

А правильный — это какой? Как понять, в каком порядке, если есть возможность смешать два произвольных блока в произвольном порядке?
А если три блока? Или четыре? Количество сочетаний блоков на одной простой странице исчисляется тысячами.
Точно ли разработчик сможет учесть всё многообразие сочетаний? Сможет?

В `BEViS` мы отказались от смешивания блоков друг с другом. Нет миксов блоков на одной ноде - нет конфликтов.

**Марат:**
Не знаю, как у вас в проектах, у нас в Яндексе довольно часто можно встретить такие записи:
```html
<div class="button button_theme_normal button_shadow_yes">кнопка</div>
```

Есть некий базовый класс и несколько модификаторов, каждый добавляет к базовому классу что-то или переопределяет
какие-то стили из базового класса.

Чем это опасно?
Вы добавляете или изменяете какое-то свойство в одном из этих трёх классов, у вас нет никакой гаранитии, что
ваши исправления не придут в конфликт весов со стилями других классов на этой ноде.

В болшом проекте, даже после небольших изменений в таких стилях хорошо бы перетестировать весь проект с нуля,
чтобы убедиться, что верстка не сломалась в тех блоках, где есть множественные классы. Проблема же в том, нет
другого механизма, кроме ручного пребора каждой страницы. А если у вас не дайбожэ SPA, и часть блоков не видна,
потому что аякс... В-общем, верстка становится нестабильной.

И это совсем не похоже на независимые блоки. Какая же это независимость, если даже внутри одного блока могут
родиться проблемы отображения? Трудно себе даже представить потенциальные конфликты в стилях, если мы смешаем
два разных блока на одной ноде.

Что делает Бивис?
Мы в такой ситуации рассуждаем так: Если в проекте нужна кнопка с темой нормал и тенью, то должен существовать отдельный класс,
в котором сразу будет и тема нормал и тень. В одном классе. Поэтому та запись с тремя классами превращается в один класс:

```html
<div class="button_normal-shadow">кнопка</div>
```

То есть мы делам блок button с view = normal-shadow. В json это записывается нами так:

```javascript
{
    block: 'button',
    view: 'normal-shadow'
}
```

А уже внутри этого вью мы смешиваем все эти разновидности кнопки и разруливаем все конфликты.
И делаем это с помощью препроцессора.

**Вадим:**
Кто сейчас не знает, что такое препроцессор? Все знают.

[схема что такое препроцесор]()


Кроме меня. Я относился к CSS-препроцессорам брезгливо. "Баловсто это", — я так считал, — "Тот же CSS, только с синтаксическим сахаром."
А сахар я не люблю, кофе могу пить и несладкий.

Только оказалось, что сахар в препроцессорах - это не то, ради чего они нужны.
Мы с их помощью делаем верстку гибкой и модульной.

Как мы решаем задачу?

```css
skin-common() {
    /* общие стили для кнопки */
}

skin-theme-normal() {
    /* цветовая тема */
}

skin-shadow() {
    /* стили добавляют тень */
}

.button {
    skin-common()
    skin-theme-normal()
}

.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();
}
```

`skin-common()`, `skin-theme-normal()`, `skin-shadow()` - это так называемые миксины, примеси по-русски. Те же `javascript`-функции.

Мощь в том, что эти функции приватны. Они не попадают напрямую в скомпилироанный css-файл. Пока из конкретного селектора не вызову этот миксин, его содержимое нигде не светится
Я создаю селектор для нормальной кнопки с тенью, явно вставляю в него вызов нужных миксинов. Если между стилями вознкли какие-то конфоликты,
я их здесь же (всё ещё на сервере) разрузлил, и в браузер пойдёт css-селетор, в котором полный порядок.

В браузер пойдёт для этого блока один css-селектор. Гарантированно работающий.

```css
.button_normal-shadow {
    skin-common();
    skin-theme-normal();
    skin-shadow();

    /* а здесь разрулил все конфликты этих миксинов */
}
```

Мы описываем стили внутри styl-файлов, они собираются в css-файлы, в которых каждый блок имеет свой собственный набор стилей, самодостаточный для работы. Независимый.
Если завтра мне нужно изменить стили в skin-common, я делаю это безбоязненно, потому что знаю - эти изменения повлияют только на вид кнопок,
а тестировать кнопки очень легко — в бивис проекте автоматически создаётся веб-страница, на которой автоматически генерятся все блоки, какие есть в вашем проекте,
со всеми вью, какие у вас есть. Её легко открыть вбраузере и проверить.

Идею так использовать препроцессор мы позаимствовали у Романа Комарова. Он предложил такую же схему для своего CSS-фреймворка Stylobat. Рома - это тот парень,
который является сейчас мейнтейнером препроцессора Stylus. Гениальный верстальщик, добрый человек. Рома, спасибо тебе большое!

Что мы имеем на выходе: один блок имеет один css-класс. Мы по-прежнему утверждаем, что блок - это просто, одного имени достаточно.

Что ещё про стили важно сказать.

Мы считаем, что css-классы нужно использовать, чтобы дать блоку какой-то внешний вид.
Другие подходы ипользуют css-классы, чтобы находить блоки в дом-дереве. Тот же jQuery с функцией $, да многие другие.

Мы так не считаем. Это неправильно. Правильно оставить css-классы для отображения, а для назначения js-поведения использовать что-то другое. Разделить поведение и отображение.


## JS-поведение блока
Как мы пишем js для блоков на странице?

В маленьких проектах мы делаем так:

```javascript
$( document ).ready(function() {

    var form = $('#my-form');
    form.submit(onSubmited);

    function onSubmited() {
        if ($('#my-form .button').css('disabled')) {
            return false;
        }
        form.submit();
    }

});
```

Для каждого блока мы описываем, что он должен делать. Здесь жэе описываем реакции на пользовательские события.

Марат, расскажи нам, как мы пишем клиенсткий `js` для блоков в бивисе?

**Марат:** В бивисе мы делаем то же самое, только не внутри ```$( document ).ready()```, а внутри модуля.

Модульных систем вы знаете много. Это и RequireJS, и CommonJS.
Модуль - это очень простая идея. Это как кассир в Макдональдсе. Когда он готов работать - он вскидывает руку: "Свободная касса!". Любой посетитель это видит и слышит и подходит к нему.
Модуль в js - эта специальная обертка, которая знает про себя, какие другие модули нужны для его работы, умеет дожидаться загрузки тех модулей,
и только после этого момента начинает выполнять код внутри себя. Прям как по domReady.

```javascript
modules.define(
    'form',
    ['button', 'input'],
    function(provide, button, input) {

        var form = $('#my-form');
        form.submit(onSubmited);

        function onSubmited() {
            if (button.css('disabled')) {
                return false;
            }
            form.submit();
        }

        provide(form);
    }
);
```

Вот эта идея.
Обратите внимание, сам код остался таким же, поменялась только обвязка. Что именно в этой обвязке?

Первая строка - объявление модуля. Та самая обертка.

Вторая строка - имя модуля

Третья - масси других модулей. Пока они не скажут про себя, что они готовы, модуль form не начнёт ничего делать.

Четвертая - содержимое моделя. Именно в этой функции и произсодит программирование поведения блока.

И пред-предпоследняя строка - это и есть вскинутая рука: "Свободная касса". Модуль form готов к работе. Так другие модули понимают, что могут использовать этот модуль

Всё. Мы описали вам устройство модулей, которые придуманы и разработаны в Яндекс.Картах. Другие модульные системы работают по тому же принципу.

**Вадим:** а внутри модулей мы используем голый jQuery?

**Марат:** Нет, мы не используем напрямую jQuery для выполнения операций над блоками.
Мы используем свой базовый класс для написания блоков. Это такой js-класс,
который позволяет оперировать в js именно нашими абстрактными блоками, а не тегами. Если нам надо найти блок, или элемент блока, мы делаем это не через dom-методы, типа getElementById,
а нашими методами.

```javascript
modules.define(
    'form',
    ['button', 'input', 'y-block'],
    function(provide, button, input, YBlock) {

        var form = inherit(YBlock, {
            __constructor: function () {
                this._bindTo(button, 'submit', this._onSubmited);

            },

            _onSubmited: function (e) {
                e.preventDefault();

                if (button.css('disabled')) {
                    return false;
                }
                this.submit();
            }
        });

        provide(form);
    }
);
```

**Вадим:** Зачем оно такое надо? Модули и свой js-класс для блоков? Почему не просто jQuery?

**Марат:** Потому что это настоящее ООП, с классами, с инстансами, с ассинхронностью. Потмоу что здесь есть четкое разделение приватных и публичных методов.


**Вадим:** Да. А ещё это нужно, чтобы максимально разделить визуальное отображение и поведение. У Бивиса получилось.

Когда бивис сгенерит html для шапки, вы увидите там такое:
```html
<div
    class="header"
    data-block-name="header">
</div>
```
Слово, запсианное в атрибуте class участвует исключительно в стилевом отображении.
А то, что написано в `data-block-name` - именно по этому атрибуту Бивис находит шапку и назначает ей js-поведение.
Оказалось, что использовать дата-атрибуты для остроения вирутального дерева блока на странице гораздо быстрее, чем использовать css-классы.

В бивисе блок может иметь один css-класс, а дата-атрибут совершенно другой. То есть вы можете спокойно удалить имя класса из class, ваш блок
потеряет стили, но поведение у него останется. И наоборот - исчезнет поведение, но останется визуально правильным.

Едиственное место, где поведение и отображение пересекаются, это состояния блока. Этого никак не избежать, потому что и в жизни оно так устроено.

Когда я бегаю по стадиону, я краснею и потею. Меняется мой внешний вид. Когда я плаваю долго в море, кожа на пальцах сморщивается и бледнеет.
У нас есть знкомые, которые так определяют, можно ли ребенку ещё плавать в бассейне:

— Сын, у тебя там кожа на ладошках уже состарилась?

— Нет, пап, не состарилась!

А сам тем временем прячет за спину помятые ладошки.

В блоке тоже самое. Например, возьмём ту же форму авторизации. По нажатию на кнопку сабмита надо проверить поле логина. Если пустое - обвести поле
логина стыдливой красной рамкой. То есть изменить отображение блока, сменить его состояние с обычного на тревожное.

Из js мы добавляем дополнительный класс, который отвечает за изменение внешнего вида в состоянии "тревога".

Вот что произойдёт в html-элемнте блока
```html
<input class="login _unfilled" type="text"/>
```

а вот что мы заранее напишем в стилях
```css
/* обычное состояние */
.login {
    ...
}

/* тревожное состояние */
.login._unfilled {
    border: 1px solid red;
}
```

И когда мы на клиенте проверим, что поле логина пустое, мы добавим в ноду к инпуту класс "_unfilled"
Мы называем такие классы состояниями. State
Имя стейта может быть любым, какое вы выберете. Вам всего лишь нужно в стилях предусмотреть, что
если js добавит такой-то стейт-класс, чтобы в отображении что-то изменилось.

Почему класс начинается с подчёркивания? Чтобы подчернуть, что он приватный для блока и чтобы легче его замечать.

Теперь понимаете, почему мы назвали наш подход BEViS?
```
B — [B]lock
E — [E]lement
Vi— [Vi]ew
S — [S]tate
```

Это всё про то, как верстать блоками.

## Сборка статики без боли

Мы почти закончили. Осталось сказать, что конечно же мы не пишем все стили в одном файле, все шаблоны в одном файле,
весь клинетский js в одном файле. Каждый блок представлен на файловой системе своей папкой, это удобно и очень по-человечески.

Ведь у меня, как и у любого человека, есть дом — место, откуда я выхожу утром на работу и куда возвращаюсь каждый вечер.
Ну, хорошо, это не дом. Это квартира в многоэтажке.
У блока тоже есть свой дом - место, где блок отдыхает и ждёт, когда его "позовут поработать" в веб-странице.
В корне проекта есть директория `/blocks`, в ней живут все блоки. Только в ней. Это дом блоков. Не ищите других мест.
Если блока здесь нет, больше нет нигде.

````
/blocks
    /header
        header.bt.js
        header.styl
        header.js
    /form
        form.bt.js
        form.styl
        form.js
````

Каждый блок хранится в своей собственной папке, где шаблоны для генераиции html описаны в bt.js, стили в styl, клиентский яваскрипт в js.
Эффективно, хотя и не ново. Когда моя дочка готовится к математике, она на парту выкладывает учебник по математике, тетрадь по математике,
угольник и карандаш — всё, что нужно именно для урока математики. У нас так же - всё, что нужно для блока находится в одной папке.

А когда учитель хочет проверить у всего класса собрать тетради на проверку, она ходит по рядам и забирает тетради с стопку.
У нас тоже есть такой сборщик. Когда в сервер приходит запрос на страницу, соирается не только htmk, но и css, и js. Это всё делает
сборщик. Почему не Ant, Make, Grunt?

Марат, зачем ты сделал [ENB](https://github.com/enb-make/enb)?

**Марат:** Наш сборщик отличается тем, что собирает любые проекты, которые строятся на модели node / target.
И он очень быстрый. Прям очень-очень быстрый. Нереально быстрый. И в нём есть встроенный сервер, он автоматически отслеживает
изменения на фаловой системе и пересобирает файлы.

**Вадим:** А ещё у твоего сборщика очень понятная документация и робот-конфигуратор, с помощью которого создавать конфиг для сборщика сможет даже моя бабушка Дуся.

**Вадим:** Марат, давай теперь увяжем всё, что мы рассказали в ту схему, котрую ты оказывал в начале.

**Марат:** Давай.

1. В адресную строку в браузере пользователь вводит `http://my-server.ru/`.

2. Браузер отправляет http-запрос к серверу и ждёт.

3. `Node.js`-сервер принимает запрос. Понимает, что нужно создать
страницу `index.html` и открывает на чтение файл `/pages/index/index.page.js`

4. Выполняет там js-инструкции, а именно: ходит за данными в бекенд, формирует декларацию страницы из `btjson`,
анализирует каждый элемент `btjson`-массива и запоминает из каких блоков будет построена будущая `HTML`-страница.

5. После этого сервер запускает `ENB`—сборщик. На этом этапе, когда сервер
 принял запрос, `ENB` начинает с того, что создаёт пустые файлы
  * `/pages/index/index.styl`,
  * `/pages/index/index.js`,
  * `/pages/index/index.bt.js`

  Если такие файлы уже есть, `ENB` пропускает этот шаг и переходит к следующему.

6. Дальше `ENB` получает от сервера на вход имя первого блока — "header". `ENB` идёт на файловую систему проекта, находит директорию `/blocks/header` и заходит в неё.

7. Ищет файл `header.js`. Если он есть - копирует его содержимое в `/pages/index/index.js`. Делает то же самое для
`bt`-файла, создавая `/pages/index/index.bt.js`. А для стилей делает то же самое, только сначала запускает `Stylus`-компилятор,
который из `header.styl` генерит CSS-селекторы, а потом уже их копирует в `/pages/index/index.css`.

8. Дальше `ENB`  выходит из `/blocks/header` и заходит в следующий блок, объявленный в btjson, например в `/blocks/form` и делает то же самое. И так повторяется для всех блоков.

9. В результате работы сборщика файлы `index.bt.js`, `index.css`, `index.js`  заполнены `BT`-шаблонами,
`CSS`-селекторами и `JS`-скриптами, необходимыми для генерации `HTML` всех блоков на странице, для их стилизации и
для программирования `js`-поведения. То есть `ENB` занимается тем, что создаёт страничные файлы.

10. Это почти всё, стилевой и яваскриптовый файлы готовы к отправке в браузер, но мы не можем пока отправлять, потому что у нас
не готов конечный `HTML` страницы. Поэтому `ENB` отключается, и контроллер `index.page.js` вызывает `BT`-шаблонизатор.

11. `BT` принимает из контроллера `btjson` и накладывает на него только что
сгенерённый `index.bt.js`, в результате чего происходит трансформация из `btjson`-а в
`HTML`-теги. В результате, в памяти сервера
формируется `HTML`-код страницы

12. Всё, это финал. `BT` создал `HTML`, `ENB` собрал `CSS` и `JS`. Сервер отправляет всё это назад в браузер по HTTP-протоколу.

**Вадим:** Теперь вы точно представляете, как работает Бивис-приложение.

Да, забыли сказать, сервер не нужно перезапускать. Правьте css/js/bt, изменения будут пересобираться сервером на лету.
Вам только браузер рефрешить надо.

## Заключение

[Документация](http://github.com/bevis-ui/docs) у бивиса прекрасная — достаточная и понятная.
Мы писали её для живых людей.

Начать работать на бивисе тоже очень просто:
```
git clone git@github.com:bevis-ui/bevis-stub.git your-project
cd your-project
make
```
После этого мы открываем в браузере ```localhost:8000``` и говорим: "Привет, Бивис!"

Пользоваться бивисом одно удовольствие, потому что 99% бивиса - это валидный javascript.
Весь этот код покрыт юнит-тестами. Он написан в очень понятном кодстайле, которым придерживается
команда Яндекс.Карт.

Мы не просим становиться нашими контрибьюторами, потому что особо нечего контрибьютить. Ведь наши
инструменты работают хорошо, а бивис-подход вполне жизнеспособный, мы доказали это на нескольких проектах.
Например `beta.maps.yandex.ru` сделан на бивисе.

Мы осознаём, что верстать на бивисе маленький сайтик — это все равно что экскаватором пытаться выкопать
лунку для гольфа — вместо лунки вы получите яму для саженца. Но если вдруг вам нужно перекопать
большое поле и вы хотите быть уверены, что в процессе копания не повредите
какие-то важные подземные коммуникации, тогда бивис - и для вас тоже.

С вами была команда Яндекс.Карт и её представители на этой конференции -  Вадим Макишвили и Марат Дулин.

Спасибо вам большое за внимание!
