# BEViS & bt

##Тезисы

_Бивис — еще один подход в разработке сайтов, который придумали в Яндексе. Это простая и понятная модель разработки, которая подходит для больших проектов, повышает их надежность._

_Это будет дружеский рассказ, такой можно услышать в офисных коридорах или на кофепойнте. Мы расскажем, как верстаем свои проекты, и почему отныне уверены в их стабильности. Вдруг и вам Бивис
приглянётся :)_

_Вы всё поймёте с первого раза. Обещаем ;)_

##План
1. Как работает наше приложение
2. Астрагируемся от DOM
3. Декларативная шаблонизация
4. Паттерн "Фасад" в html-верстке
5.

##Начало

Привет, я Вадим, это мой друг Марат. Мы из Яндекса. Из Карт.
Спасибо, что пригласили :)

Мы любим строить сайты. И нам хочется получать от этого удовольствие.
Теперь мы получаем радость, потому что придумали Бивис.

У меня есть ребенок. Восемь лет девочке. У кого из вас есть ребенок и он чуть-чуть умеет на html/css и javascript?
Принесите ему сегодня ссылку на документацию к БИВИС, и завтра он принесёт вам полноценный сайт, работающий на Node.js

Амбициозно, но заманчиво? Но вы-то не школьники. А кто вы?

Если вы:

1. Разработчик из команды, в которой больше 4-5 человек

2. Разработчик сервиса (сервисов), в котором много похожих блоков или страниц

3. Разработчик общей библиотеки блоков

тогда Бивис для вас тоже.

Должны сразу признаться. У нас нет цели заполучить вас в контрибьютеры или принести вам новую веб-религию. Мы не
претендуем на мировые лавры. Мы просто с вами по-братски делимся своими придумками.

Ну всё, хватит общих слов, давайте к станку!

## Приложение

[Слайд](http://makishvili.github.io/bevis/index.html?full#2)

Запрос из браузера попадает на некий http-сервер. Это может быть Apache или Nginx или любой другой.
Запрос направляется в контроллер - программу, написанную, например, на PHP или на Python, которая
 получает данные из бекенда (из MySql или серванта), и передаёт в шаблоны представления, кторые и генерят конечный html.

Эта схема известна каждому.
Ну так мы её и не меняли. Мы поменяли технологии и шаблонизатор.

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

Вместо Apache или Nginx у нас Node.js. Вместо php-страничек мы пишем `js-файл`, в котором обращаемся в сервант за данными,
накладываем на них шаблоны представления, которые тоже напсисаны на `js`, и отдаём пользователю конечный `html`.

Видите - схема та же. Только всё на яваскрипте, на серверном яваскрипте.

----

Зачем изобретать новый велосипед, если есть Смарти, есть Джанга, есть XSLT, в конце концов?

Школьнику, который знает чуть-чуть html/css и немного javascript-а, не нужно учить серверный язык программирования -
ни PHP, ни Ruby, ни Python. Что ещё учить не надо - Perl, Java, C#, XSL, продолжайте. Я понимаю,
что у каждого языка свои преимущества в определённых ситуациях. Но мы и не говорим, что они не нужны. Мы говорим,
 что типовые задачи веб-разработки можно успешно делать на серверном javascript, который мы уже знаем.

Вот и мы захотели обрести полный контроль над фронтендом. Самое время! Есть все возможности!

----

Посмотрим на схему чуть подробнее.


Итак, запрос от пользователя пришёл на сервер. Что дальше?

1. `Node.js`-приложение приняло запрос и передало контроль файлу `index.page.js`.
2. Тот как-то сходил за данными - вообще не важно как - или запросами в базу или в http-запросами в бекенд, не важно.
3. Из бекенда пришли данные в каком-то виде. Наш контроллер трансформирует эти сырые данные в `JSON` специального вида, который мы называем `BTJson`
   [Слайд](http://makishvili.github.io/bevis/index.html?full#4)
4. И после этого шаблоны с раширением `bt.js` генерят из `btjson` конечный `HTML`.

Что такое `BTJson?` Это способ описывать веб-страницы.

В статических сайтах страница описывается чистым html, в php-сайтах - php-командами, в сайтах на XSLT - в виде xml, а у нас в виде json.
Вот так:

```javascript
[
    {
        block: 'head'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

В какой-то такой html он превращается на лету:
```
<div class="head">
    ...
</div>

<form class="authorization" action="/?task=login">
    ...
</form>
```
Там где три точки, там весь остальной html, нужный для устройства шапки или формы логина.


Мы больше не пишем html-теги, потому что в Яндексе мы давно научились смотреть на веб-страницу,
как на набор блоков. Каждый выполняет свою простую функцию, вместе - это страница.

Вы, скорее всего, тоже разбиваете страницу на небольшие части, и называете их про себя как-то: кто модулями,
кто ещё как. Мы называем блоками, потому что мы из Яндекса, а там родилась концепция верстки,
в которой впервые прозвучало слово "блок". :)

Вы помните такую концепцию?

2006 год. Родилась концепция АНБ. Это были рекомендации по оформлению кода в проекте.

2009-2010 года. Родился БЭМ. Фреймворк для разработки сайтов. Это реализация АНБ, которую насытили дополнительными
идеями, которых не было ещё в 2006 году.

2013 год. Мы придумали Бивис. Это тоже фреймворк для разработки сайтов. Фактически,
это не что иное, как альтернативная реализация АНБ, сделанная после БЭМа. Мы не согласны с реализацией АНБ
командой БЕМ-разработчиков, и реализовали фреймфорк, который, как нам кажется, реализует первоначальные принципы АНБ
 — настоящую абсолютную независимость блоков.

## Что такое блок?
Это некая логическая единица веб-страницы. Абстрактная штука. Давайте будем считать,
что набор тегов, которые формируют структуру формы авторизации, это и есть некий блок. Назовём его authorization.
Внутри него есть некие теги, без которых форма не сможет выполнять свою функцию - принимать данные от пользователя и
откправлять их на сервер - текстовый инпут и сабмит-кнопка. Эти теги бессмысленны без формы,
поэтому их можно считать элементами блока. Такая вот абстракция.

А вокруг этой абcтракции придумали немного правил для облегчения разработки.

* Для стилизации блоков не используем id, а только css-классы.
* Чтобы исключить наложение стилей элементов от разных блоков, вложенных друг в друга, классы для элементов обязательно
включают в себя имя блока
    ```
    <div class="page">
        <h1 class="page__title"></h1>

        <div class="article">
            <h2 class="article__title"></h2>
        </div>
    </div>
    ```
* Чтобы в `html/css` сэмулировать `наследование и полиморфизм`, придуманы модификаторы. Например,
на странице две кнопки, но одна синяя, другая зеленая. Пишем стили для синей кнопки, а для того,
чтобы сделать вторую зеленую, используем синюю, но модифицируем дополнительным классом,
в котором только одно  css-свойство:
   ```html
    <style>
        .button {
            /* все стили для синей кнопки */
        }

        .button_green {
            background: green;
        }
    </style>

   <div class="button">синяя кнопка</div>
   <div class="button button_green">зеленая</div>
   ```

Тогда, в 2006 году, это были только рекомендации, не было никаких инструментов, не было фреймфорков,
мы писали код тегами. Но сейчас есть Бивис, который понять легко, а использовать ещё легче :)


## Описание страницы обязано быть простым

Это важно. Описание страницы должно быть максимально простым. Чем предмет проще, тем легче им пользоваться. Бабушка
моей жены любит печь хлеб сама. Мы подарили ей хлебопечку. Казалось бы - насыпь муки, дрожжей,
налей воды и масла и нажми пару кнопок - очень просто. Но бабушка Дуся не пользуется,
потому что не может запомнить в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Пользуется газовой духовкой - куда проще - поджечь комфорку, сунуть противень внутрь, закрыть дверцу.

Мы хотим получать удовольствие от верстки, а не боль. Поэтому описание блоков на странице обязано быть таким,
чтобы не приходилось изучать талмуды, чтобы понять, что блок делает.

Вот такие описания блоков.
```javascript
[
    {
        block: 'head'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Смотрите, здесь не описано ни одного элемента, ни одного тега и атрибута. Но из каждой декларации сгенерится
развесистый html, например это может быть такой:

```
<div class="head">
    <a class="head__logo" href="/"><img src="logo.png" /></a>

    <h1 class="head__title">Демо-страница</h1>

    <a class="head__rss" href="/?rss"><img src="rss.png" /></a>
</div>

<form class="authorization" action="/?task=login">
    <input class="authorization__login" value=""/>
    <button class="authorization__submit"/>
</form>
```
Или даже больше. Но я не хочу думать про такой html. Я хочу мыслить простыми предметами - блоками. А что о блоке мне
нужно знать, чтобы позвать его на страницу? Да только имя. И это так по человечески. Ведь,
когда я хочу позвать к себе в гости Марата, я делаю этоочень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена яблочный пирог испечёт, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову его отдельно, отдельно его жену и каждого ребенка в отдельности. Нет, только его,
а уж он сам приведеёт всё семейсвто, будьте уверены.

```javascript
    {
        друг: 'Марат'
    }
```

И с блоком так же. Я НЕ ХОЧУ думать, о том, как он внутри устроен, из каких элементов. Я зову его просто по имени. Ну
 и если надо сообщаю блоку какую-то дополнительную информацию. Командир в окопе кричит сержанту: "Сержант Петренко,
 прикрыть правый фланг!".

```javascript
{
    рядовой: 'Петренко',
    стрелять: '/?туда'
}
```
Всё! Командир приказал — Петренко сделал. И пусть Петренко сам решает, как это делать — то ли вести самому автоматный огонь
в указанном направлении, то ли гранатами точку подавлять, то ли других бойцов послать штурмом фланг занять. Командиру
какое дело до этих деталей вообще?

Ну что, похоже на правду?

```javascript
[
    {
        block: 'head'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Пусть блок сам решает, в какой html он должен превратиться, чтобы лучшим образом выполнить свою задачу.
Как он устроен внутри, я как пользователь блока, думать не хочу.

### Внутренности блока

Ну, в самом деле, я когда в ресторан прихожу, и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша,
нагрей суп в кастрюле, потом налей два половника в глубокую тарелку,
насыпь сверху зелени и сметаны ложку и только после этого неси мне." Нет, я просто говорю: "Мне солянку". Я точно
знаю, что в кафе солянка уже сварена, её сейчас мне подадут.

И с шапкой так же: "Мне шапку!"
```javascript
{
    block: 'head'
}
```
Если представление блока уже разработано кем-то по правилам Бивиса, например в какой-то общей библиотеке,
вам хорошо — позвали блок и voila — сегенерировался нужный html блока.

Но это когда вы пользуетесь готовой библиотекой блоков и в рестораны обедать ходите.

Другое дело, когда я дома жене скажу: "Хочу на ужин борщ с фасолью и сметаной". Знаете,
что мне жена ответит? "Легко, родной! Картошку почисть..."

Улавливаете? Если вы создаёте представление для нового блока, вам придётся предватительно самому и картошку начистить и фасоль вымочить,
и мясо кубиками нарезать. То есть сварить борщ по некоторым правилам. И только потом вы сможете щелкнуть пальцами и
борщ окажется у вас в тарелке.

То есть нужно написать шаблоны для представления. Для трансформации данных в html.

Как выглядят шаблоны, которые мы писали на Смарти или на Джанге?

Они выглядят, как html-код, в который точечно добавляются данные. Как будто шприцом обкалываем:

[слайд]()

```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервиcный центр.</p<
{% endif %}
```

И с такими шаблонами есть проблема. Как на другой странице вылить этот же список?
Придётся и там писать тот же ul и тот же цикл. Реиспользовать представление становится труднее.

В бивисе мы решаем эту задачу с помощью декларативных шаблонов.

На XSLT писали? XML в HTML трансформировали? Тогда вы нас понимаете - шаблоны как в xsl
А кто не писал на XSL, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это CSS-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

CSS-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо явных инструкций (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Матчатся или не матчатся.

Вспомним нашу схему. Браузер запрашивает страницу, сервер обрабатывает ваш запрос, получает данные, формирует `btjson`

[Слайд](http://makishvili.github.io/bevis/index.html?full#4)

Предположим, что в данных у нас такой простой btjson - одно только объявление, что на старнице должна быть шапка.

```javascript
{
    block: 'head'
}
```

Как выглядит шаблон, которые превратит это в html? Заглянем внурь файла `index.bt.js`:

```javascript
bt.match('head', function (ctx) {

    ctx.setTag('div');

});
```

Шаблон записывается в виде функции `match`, в которую мы передаём имя блока. Очень похоже на CSS.
А вторым аргументом пишем функцию, внутрь которой приходит исходный `btjson` в переменной `ctx`
А в функции сказано - создай тег `div`

Конкретно этот шаблон сегенерит простой `html`
```html
<div class="head"></div>
```

`BT` - это и есть повар в ресторане или ваша жена на кухне.

Такой шаблон выглядит глупо, бесполезно. Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок.

Я добавил комментарии в код, чтобы вы всё поняли, а я помолчу.

```javascript
// регистрируем матчер для блока head
bt.match('head', function (ctx) {

    // устанавливаем HTML тег для самой шапки
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });

});

// регистрируем матчер для элемента title блока head
// внутри ctx уже json, переданный в родительском ctx.setContent()
bt.match('head__title', function (ctx) {

    // выставляем тег h1 для элемента title
    ctx.setTag('h1');

    // Получаем параметр text
    var text = ctx.getParam('text');

    // задаём содержимое заголовку
    ctx.setContent(text);

});
```

Результат:
```html
<div class="head">
    <h1 class="head__title">CodeFest 2014</h1>
</div>
```

А теперь сделаем шапку настраиваемой - чтобы можно было задавать текст заголовка на жестко, а гибко.
Предполагаю, что имя заголовка нам придёт из базы и контроллер создаст `btjson` с параметром блока, назовём его `text`

```javascript
{
    block: 'head',
    text: 'CodeFest 2014, Новосибирск'
}
```

Изменим одну тсроку в шаблоне, будем принимать значение параметра:

```javascript
// регистрируем матчер для блока head
bt.match('head', function (ctx) {

    ctx.setTag('div');

    ctx.setContent({
        elem: 'title',
        text: ctx.getParam('text') // получаем значение из параметра
    });

});


bt.match('head__title', function (ctx) {

    ctx.setTag('h1');

    var text = ctx.getParam('text');

    ctx.setContent(text);

});
```

Наш результат:

```html
<div class="head">
    <h1 class="head__title">CodeFest 2014, Новосибирск</h1>
</div>
```

А вот посмотрите на реальный пример их Яндекса. Это btjson-описание шапки.
В нём одно обязательно поле - имя блока, остальные поля - это необязательные параметры, опции:

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Так оно выглядит в браузере:

[живое демо]

##Вам кажется это избыточным?
Вам привычнее императивные шаблоны вроде тех, что есть в Смарти и в Джанго. Мы вас понимаем. Кажется, что те шаблоны писать проще - написал html страницы,
заменил контент шаблонными переменными и всё.

Но как такие шаблоны обеспечиваю реюзабельность одних и тех же блоков на разных страницах? Как эти шаблоны гарантируют стабильную верстку?
Никак. Когда вы захотите заменить верстку какого-то блока с дивов на табличку, вам придётся сделать это во всех Смарти-шаблонах, где этот блок уже описан.
И попробуйте сказать, что ни разу при этом не ошибётесь. Мы не поверим :)

Наш подход хорош тем, что на старнице нет описания того, КАК должен выглядеть блок, а только само указание, что "здесь есть такой-то блок и
у него такие-то параметры". Это же прям как в настоящем программированнии. Паттерн ["фасад"](http://ru.wikipedia.org/wiki/Фасад_(шаблон_проектирования)).
Класс выставляет наружу интерфейсные методы, которые не меняются и поддерживаются пожизненно, а внутрення реализация класса скрыта от глаз, находится в приватной области.
Мы создали то же самое для html-верстки.

BTJson блока - это внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на примере. При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Но самое ценное в том, что отныне можете менять шаблоны, генерирующие html как угодно часто, вам не нужно при этом переписывать
все страницы. И не бояться, что на какой-то странице что-то пойдёт не так. АПИ блока гарантирует результат.

Кто-то может возразить, что мы пишем больше кода - каждый декларативный шаблон нужно явно описать, там задать какой тег выливать,
какие элементы внутри блока генерить. Ну так вы же на Смарти шаблонах тоже всё это пишете, только в виде чистого html.

Вы же тоже пишете это же самое, только на чистом html. А мы пишем это на js. Вы скажете, что мы пишем куда больше букв и покажете мне эти две строки.
```javascript
ctx.setTag('div');
```

```html
<div></div>
```

Да, наша запись на семь символов длиннее, но только при условии, что вы руками пишете каждый символ, когда пишете теги. Скорее всего вы пользуетесь
аутокомплитом, ну  а мы пользуемся сниппетами. Нажал хоткей, вписал только три символа `div` и у нас готова строка ```javascript ctx.setTag('div'); ```

Я веду к тому, что если вы пишете императивные шаблоны, мы с вами прикладываем сравнительно одинаковое количество сил для написания шаблонов,
но в бивисе мы получаем код с очевидными преимуществами.

