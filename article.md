# BEViS & bt

##Тезисы

_Бивис — еще один подход в разработке сайтов, который придумали в Яндексе. Это простая и понятная модель разработки, которая подходит для больших проектов, повышает их надежность._

_Это будет дружеский рассказ, такой можно услышать в офисных коридорах или на кофепойнте. Мы расскажем, как верстаем свои проекты, и почему отныне уверены в их стабильности. Вдруг и вам Бивис
приглянётся :)_

_Вы всё поймёте с первого раза. Обещаем ;)_

##План
1. Как работает наше приложение
2. Абстрагируемся от DOM
3. Декларативная шаблонизация
4. Паттерн "Фасад" в html-верстке
5.

##Начало

Привет, я Вадим, это мой друг Марат. Мы из Яндекса. Из Карт.
Спасибо, что пригласили :)

Мы любим строить сайты. И нам хочется получать от этого удовольствие.
Теперь мы получаем радость, потому что придумали Бивис.

Если вы работаете в команде, в которой больше 4-5 человек, разрабатываете сервис, в котором много
похожих блоков или страниц, или вы разработываете общую библиотеку блоков, тогда бивис и для вас тоже.

Сразу признаемся. У нас нет цели заполучить вас в контрибьютеры или принести вам новую веб-религию. Мы не
претендуем на мировые лавры. Мы просто с вами по-братски делимся своими придумками.

Ну всё, хватит общих слов, давайте к станку!

## Приложение

Как работает веб-приложение? Схематично это выглядит так.

[Слайд](http://makishvili.github.io/bevis/index.html?full#2)

Запрос из браузера попадает на некий http-сервер. Это может быть Apache или Nginx или любой другой.
Запрос направляется в контроллер - программу, написанную, например, на PHP или на Python, которая
 получает данные из бекенда (из MySql или серванта), и передаёт в шаблоны представления, кторые и генерят конечный html.

Эта схема известна каждому. Ну так мы её и не меняли. Мы поменяли технологии и шаблонизатор.

[Слайд](http://makishvili.github.io/bevis/index.html?full#3)

Вместо Apache или Nginx у нас Node.js. Вместо php-страничек мы пишем программу на серверном `js`, в которой обращаемся в сервант за данными,
накладываем на них шаблоны представления, которые тоже напсисаны на серверном `js`, и отдаём пользователю конечный `html`.

Видите - схема та же. Только всё на яваскрипте, на серверном яваскрипте.

----

Зачем изобретать новый велосипед, если есть Смарти, есть Джанга, есть XSLT, в конце концов?

Две причины: простота и ассинхронность. Простота в том, что сверстать приложение может любой школьник, который умеет на html/css/javascript
Ему не нужно учить новый язык программирования - ни PHP, ни Ruby, ни Python. Что ещё учить не надо - Perl, Java, C#, XSL, продолжайте. Я понимаю,
что у каждого языка свои преимущества в определённых ситуациях. Но мы и не говорим, что они не нужны. Мы говорим,
 что типовые задачи веб-разработки можно успешно делать на серверном javascript, который мы уже знаем.

И вторая причина - асинхронность. Для больших проектов важна скорость. Да и просто это модно, а мы ребята модные :)

Иными словами, мы захотели обрести полный контроль над фронтендом. Самое время! Есть все возможности!

----

Как выглядит контроллер в PHP или Python?
Это набор PHP/Puthon-команд, которые ходят в бекенд за данными.

Как выглядит наш контроллер `index.page.js?`
Это набор Javascript-команд. Так как мы пишем на Node.js, наш яваскрипт завернут в Node.js модули. И выглядит это примерно так:

```javascript
module.exports = function (pages) {
    pages.declare('index-page', function (params) {

        return {
            block: 'page',
            styles: 'index.css',
            scripts: 'index.js'

            body: [
                {
                    block: 'head'
                },
                {
                    block: 'authorization',
                    actionUrl: '/?task=login'
                }
            ]
        };

    });
};
```
Если вы на Node.js не писали, не пугайтесь, не обращайте внимания на первую строку. Относитесь к ней, как обвязке, без которой нельзя.
Всё интересное происходит внутри. А внутри обычный javascript. Видите вызов функции page.declare()?

Есть глобальный объект `page`, у которого есть метод `declare`. Выражаясь языком юристов, это "декларация о намерениях" :)
Мы декларируем, что наша страница будет состоять из нескольких компонентов и перечисляем  эти компоненты в каком-то простом формате.

Мы сказали, что страница состоит из блока `page`, в теле которого есть два других блока - `шапка` и `форма авторизации`.
Это абсолютно валидный `JSON`. Совершенно обычный `JSON`. Бивис создавался, как фреймворк, который использует совершенно валидные нативные конструкции.
В этом json есть только одно служебное поле, оно называется block. Остальные поля, которые вы видите, могу называться как вам нравится.

## Абстрагируемся от DOM
Почему блок? Зачем какой-то `JSON`? И что оно вообще такое?

Очень трудно сделать веб-сервис, если верстать его тегами.
Взять хотя бы шапку. Она может состоять из десятка тегов: дивы, спаны, имаджи и даже инпуты. Это же хаос.

Посмотрите на любую картину вблизи - это же хаос - цветные мазочки-мазочки-мазочки. Ни черта не разобрать.

[ утро в сосновом бору zoom x 10]()

А если отойти от картины - Оооо, так это де Шишкин Иван Иванович с его знаменитиыми мишками.

[ утро в сосновом бору zoom x 1]()

Так и мы отодвинулись от html-тегов и увидели, что верстаем-то не тегами, а некими компонентыми, модулями, блоками.
Мы абстрагировались от html-тегов. Мы больше не пишем их, потому что в Яндексе давно научились смотреть на веб-страницу,
как на набор компонентов, или блоков, как мы привыкли их называть. Каждый компонент выполняет свою простую функцию, вместе - это страница.

Вы, скорее всего, тоже разбиваете страницу на небольшие части, и называете их про себя как-то: кто модулями,
кто ещё как. Мы называем блоками, потому что мы из Яндекса, а там родилась концепция верстки,
в которой впервые прозвучало слово "блок". :)

```javascript
 [
    {
        block: 'head'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Здесь мы задекларировали, что на странице будет всего два блока - шапка и форма авторизации. После наложения шаблонов, эта декларация превратится в
в какой-то такой html:
```
<div class="head">
    ...
</div>

<form class="authorization" action="/?task=login">
    ...
</form>
```
Там где три точки, там весь остальной html, нужный для устройства шапки или формы логина.

## Истоки
Вы помните АНБ?

2006 год. Родилась концепция АНБ. Это были рекомендации по оформлению кода в проекте.

2009-2010 года. Родился БЭМ. Фреймворк для разработки сайтов. Это реализация АНБ, которую насытили дополнительными
идеями, которых не было ещё в 2006 году.

2013 год. Мы придумали Бивис. Это тоже фреймворк для разработки сайтов. Фактически,
это не что иное, как альтернативная реализация АНБ, сделанная после БЭМа. Мы не согласны с реализацией АНБ
командой БЕМ-разработчиков, и реализовали фреймфорк, который, как нам кажется, реализует первоначальные принципы АНБ
 — настоящую абсолютную независимость блоков.

## Что такое блок?
Это некая логическая единица веб-страницы. Абстрактная штука. Давайте будем считать,
что набор тегов, которые формируют структуру формы авторизации, это и есть некий блок. Назовём его authorization.
Внутри него есть некие теги, без которых форма не сможет выполнять свою функцию - принимать данные от пользователя и
откправлять их на сервер - текстовый инпут и сабмит-кнопка. Эти теги бессмысленны без формы,
поэтому их можно считать элементами блока. Такая вот абстракция.

А вокруг этой абcтракции придумали немного правил для облегчения разработки.

* Для стилизации блоков не используем id, а только css-классы.
* Чтобы исключить наложение стилей элементов от разных блоков, вложенных друг в друга, классы для элементов обязательно
включают в себя имя блока
    ```
    <div class="page">
        <h1 class="page__title"></h1>

        <div class="article">
            <h2 class="article__title"></h2>
        </div>
    </div>
    ```
* Чтобы в `html/css` сэмулировать `наследование и полиморфизм`, придуманы модификаторы. Например,
на странице две кнопки, но одна синяя, другая зеленая. Пишем стили для синей кнопки, а для того,
чтобы сделать вторую зеленую, используем синюю, но модифицируем дополнительным классом,
в котором только одно  css-свойство:
   ```html
    <style>
        .button {
            /* все стили для синей кнопки */
        }

        .button_green {
            background: green;
        }
    </style>

   <div class="button">синяя кнопка</div>
   <div class="button button_green">зеленая</div>
   ```

Тогда, в 2006 году, это были только рекомендации, не было никаких инструментов, не было фреймфорков,
мы писали код тегами. Но сейчас есть Бивис, который понять легко, а использовать ещё легче :)


## Описание страницы обязано быть простым

Это важно. Описание страницы должно быть максимально простым. Чем предмет проще, тем легче им пользоваться. Бабушка
моей жены любит печь хлеб сама. Мы подарили ей хлебопечку. Казалось бы - насыпь муки, дрожжей,
налей воды и масла и нажми пару кнопок - очень просто. Но бабушка Дуся не пользуется,
потому что не может запомнить в какой последовательности какие кнопки нажимать - из инструкции старому человеку это
непонятно. Пользуется газовой духовкой - куда проще - поджечь комфорку, сунуть противень внутрь, закрыть дверцу.

Мы хотим получать удовольствие от верстки, а не боль. Поэтому описание блоков на странице обязано быть таким,
чтобы не приходилось изучать талмуды, чтобы понять, что блок делает.

Вот такие описания блоков.
```javascript
[
    {
        block: 'head'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Смотрите, здесь не описано ни одного элемента, ни одного тега и атрибута. Но из каждой декларации сгенерится
развесистый html, например это может быть такой:

```
<div class="head">
    <a class="head__logo" href="/"><img src="logo.png" /></a>

    <h1 class="head__title">Демо-страница</h1>

    <a class="head__rss" href="/?rss"><img src="rss.png" /></a>
</div>

<form class="authorization" action="/?task=login">
    <input class="authorization__login" value=""/>
    <button class="authorization__submit"/>
</form>
```
Или даже больше. Но я не хочу думать про такой html. Я хочу мыслить простыми предметами - блоками. А что о блоке мне
нужно знать, чтобы позвать его на страницу? Да только имя. И это так по человечески. Ведь,
когда я хочу позвать к себе в гости Марата, я делаю этоочень просто - я зову его по имени и говорю: "Марат,
а приходи к нам в гости сегодня, жена яблочный пирог испечёт, посидим". А у Марата жена и двое детей,
к примеру. Я же не зову его отдельно, отдельно его жену и каждого ребенка в отдельности. Нет, только его,
а уж он сам приведеёт всё семейсвто, будьте уверены.

```javascript
    {
        друг: 'Марат'
    }
```

И с блоком так же. Я НЕ ХОЧУ думать, о том, как он внутри устроен, из каких элементов. Я зову его просто по имени. Ну
 и если надо сообщаю блоку какую-то дополнительную информацию. Командир в окопе кричит сержанту: "Сержант Петренко,
 прикрыть правый фланг!".

```javascript
{
    рядовой: 'Петренко',
    стрелять: '/?туда'
}
```
Всё! Командир приказал — Петренко сделал. И пусть Петренко сам решает, как это делать — то ли вести самому автоматный огонь
в указанном направлении, то ли гранатами точку подавлять, то ли других бойцов послать штурмом фланг занять. Командиру
какое дело до этих деталей вообще?

Ну что, похоже на правду?

```javascript
[
    {
        block: 'head'
    },
    {
        block: 'authorization',
        actionUrl: '/?task=login'
    }
]
```

Пусть блок сам решает, в какой html он должен превратиться, чтобы лучшим образом выполнить свою задачу.
Как он устроен внутри, я как пользователь блока, думать не хочу.

### Внутренности блока

Ну, в самом деле, я когда в ресторан прихожу, и заказываю солянку, я же не даю указаний официанту: "Так, дорогуша,
нагрей суп в кастрюле, потом налей два половника в глубокую тарелку,
насыпь сверху зелени и сметаны ложку и только после этого неси мне." Нет, я просто говорю: "Мне солянку". Я точно
знаю, что в кафе солянка уже сварена, её сейчас мне подадут.

И с шапкой так же: "Мне шапку!"
```javascript
{
    block: 'head'
}
```
Если представление блока уже разработано кем-то по правилам Бивиса, например в какой-то общей библиотеке,
вам хорошо — позвали блок и voila — сегенерировался нужный html блока.

Но это когда вы пользуетесь готовой библиотекой блоков и в рестораны обедать ходите.

Другое дело, когда я дома жене скажу: "Хочу на ужин борщ с фасолью и сметаной". Знаете,
что мне жена ответит? "Легко, родной! Картошку почисть..."

Улавливаете? Если вы создаёте представление для нового блока, вам придётся предватительно самому и картошку начистить и фасоль вымочить,
и мясо кубиками нарезать. То есть сварить борщ по некоторым правилам. И только потом вы сможете щелкнуть пальцами и
борщ окажется у вас в тарелке.

То есть нужно написать шаблоны для представления. Для трансформации данных в html.

Как выглядят шаблоны, которые мы писали на Смарти или на Джанге?

Они выглядят, как html-код, в который точечно добавляются данные. Как будто шприцом обкалываем:

[слайд]()

```html
<p>Уважаемый {{ person }}</p>
<p>Ваш заказ от {{ date:"F j, Y" }} принят на обработку.</p>
<p>Пожалуйста, убедитесь, что всё выбрано верно:</p>

<ul>
{% for item in item_list %}
    <li>{{ item }}</li>
{% endfor %}
</ul>

{% if ordered_warranty %}
    <p>Гарантия - 12 месяцев.</p>
{% else %}
    <p>Со всеми неполадками обращайтесь в наш сервиcный центр.</p<
{% endif %}
```

И с такими шаблонами есть проблема. Как на другой странице вылить этот же список?
Придётся и там писать тот же ul и тот же цикл. Реиспользовать представление становится труднее.

В бивисе мы решаем эту задачу с помощью декларативных шаблонов.

На XSLT писали? XML в HTML трансформировали? Тогда вы нас понимаете - шаблоны как в xsl
А кто не писал на XSL, сейчас поймёте. Это легко.

Что это?

```css
h1 {
    color: red;
}
```

Даже школьник ответит: "Это CSS-селектор". Ну тогда поздравляем, вы умеете писать декларативные шаблоны.

CSS-селекторы - это пример самых настоящих декларативных шаблонов. Заголовок станет красным только тогда, когда он есть на странице. Если h1 на
странице нет, то и красить нечего, правда?

В этом вся соль декларативных языков программирования. Вместо явных инструкций (как в смарти-шаблонах) - только матчеры,
которые применяются к данным, если они есть. Матчатся или не матчатся.

Вспомним нашу схему. Браузер запрашивает страницу, сервер обрабатывает ваш запрос, получает данные, формирует `btjson`

[Слайд](http://makishvili.github.io/bevis/index.html?full#4)

Предположим, что в данных у нас такой простой btjson - одно только объявление, что на старнице должна быть шапка.

```javascript
{
    block: 'head'
}
```

Как выглядит шаблон, которые превратит это в html? Заглянем внурь файла `index.bt.js`:

```javascript
bt.match('head', function (ctx) {

    ctx.setTag('div');

});
```

Шаблон записывается в виде функции `match`, в которую мы передаём имя блока. Очень похоже на CSS.
А вторым аргументом пишем функцию, внутрь которой приходит исходный `btjson` в переменной `ctx`
А в функции сказано - создай тег `div`

Конкретно этот шаблон сегенерит простой `html`
```html
<div class="head"></div>
```

`BT` - это и есть повар в ресторане или ваша жена на кухне.

Такой шаблон выглядит глупо, бесполезно. Давайте усложнять. Я хочу, чтобы внутри шапки появился заголовок.

Я добавил комментарии в код, чтобы вы всё поняли, а я помолчу.

```javascript
// регистрируем матчер для блока head
bt.match('head', function (ctx) {

    // устанавливаем HTML тег для самой шапки
    ctx.setTag('div');

    // Генерим внутри шапки новый btjson и устанавливаем его, как содержимое шапки
    ctx.setContent({
        elem: 'title', // указываем элемент title в качестве содержимого
        text: 'CodeFest 2014' // произвольный текст для заголовка
    });

});

// регистрируем матчер для элемента title блока head
// внутри ctx уже json, переданный в родительском ctx.setContent()
bt.match('head__title', function (ctx) {

    // выставляем тег h1 для элемента title
    ctx.setTag('h1');

    // Получаем параметр text
    var text = ctx.getParam('text');

    // задаём содержимое заголовку
    ctx.setContent(text);

});
```

Результат:
```html
<div class="head">
    <h1 class="head__title">CodeFest 2014</h1>
</div>
```

А теперь сделаем шапку настраиваемой - чтобы можно было задавать текст заголовка на жестко, а гибко.
Предполагаю, что имя заголовка нам придёт из базы и контроллер создаст `btjson` с параметром блока, назовём его `text`

```javascript
{
    block: 'head',
    text: 'CodeFest 2014, Новосибирск'
}
```

Изменим одну тсроку в шаблоне, будем принимать значение параметра:

```javascript
// регистрируем матчер для блока head
bt.match('head', function (ctx) {

    ctx.setTag('div');

    ctx.setContent({
        elem: 'title',
        text: ctx.getParam('text') // получаем значение из параметра
    });

});


bt.match('head__title', function (ctx) {

    ctx.setTag('h1');

    var text = ctx.getParam('text');

    ctx.setContent(text);

});
```

Наш результат:

```html
<div class="head">
    <h1 class="head__title">CodeFest 2014, Новосибирск</h1>
</div>
```

А вот посмотрите на реальный пример их Яндекса. Это btjson-описание шапки.
В нём одно обязательно поле - имя блока, остальные поля - это необязательные параметры, опции:

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Так оно выглядит в браузере:

[живое демо]

##Вам кажется это избыточным?
Вам привычнее императивные шаблоны вроде тех, что есть в Смарти и в Джанго. Мы вас понимаем. Кажется, что те шаблоны писать проще - написал html страницы,
заменил контент шаблонными переменными и всё.

Но как такие шаблоны обеспечиваю реюзабельность одних и тех же блоков на разных страницах? Как эти шаблоны гарантируют стабильную верстку?
Никак. Когда вы захотите заменить верстку какого-то блока с дивов на табличку, вам придётся сделать это во всех Смарти-шаблонах, где этот блок уже описан.
И попробуйте сказать, что ни разу при этом не ошибётесь. Мы не поверим :)

Наш подход хорош тем, что на старнице нет описания того, КАК должен выглядеть блок, а только само указание, что "здесь есть такой-то блок и
у него такие-то параметры". Это же прям как в настоящем программированнии. Паттерн ["фасад"](http://ru.wikipedia.org/wiki/Фасад_(шаблон_проектирования)).
Класс выставляет наружу интерфейсные методы, которые не меняются и поддерживаются пожизненно, а внутрення реализация класса скрыта от глаз, находится в приватной области.
Мы создали то же самое для html-верстки.

BTJson блока - это внешнее АПИ блока, а BT-шаблоны - это приватная реализация блоков.

Ощутите мощь этой идеи на примере. При такой простой декларации шапки, конечная html-верстка может какой угодно сложной.

```javascript
{
    block: "y-header",

    view: "islet-search",
    showSearch: true,
    showSuggest: true,
}
```

Но самое ценное в том, что отныне можете менять шаблоны, генерирующие html как угодно часто, вам не нужно при этом переписывать
все страницы. И не бояться, что на какой-то странице что-то пойдёт не так. АПИ блока гарантирует результат.

Кто-то может возразить, что мы пишем больше кода - каждый декларативный шаблон нужно явно описать, там задать какой тег выливать,
какие элементы внутри блока генерить. Ну так вы же на Смарти шаблонах тоже всё это пишете, только в виде чистого html.

Вы же тоже пишете это же самое, только на чистом html. А мы пишем это на js. Вы скажете, что мы пишем куда больше букв и покажете мне эти две строки.
```javascript
ctx.setTag('div');
```

```html
<div></div>
```

Да, наша запись на семь символов длиннее, но только при условии, что вы руками пишете каждый символ, когда пишете теги.
Вы же не в `notepad.exe` код пишете, надеюсь?

Вы пользуетесь аутокомплитом, то есть написали открывающую скобку, затем букву `d` и нажали хоткей для аутокомплита.
Или если [Дзен-кодингом](http://pepelsbey.net/2008/08/zen-html/) набираете html, который придумал Вадим Макеев, а разработал Сергей
Чикуёнок, и теперь он называется [Emmet](http://emmet.io/), тогда вы вообще пишете три символа `div` и нажимаете `tab`.

Ну, а мы пользуемся сниппетами. Нажал хоткей, вписал только три символа `div` и у нас готова строка ```ctx .setTag ('div');```

Я веду к тому, что вы пишете императивные шаблоны, а мы декларативные и прикладываем мы сравнительно одинаковое количество сил для написания шаблонов.
Но мы в бивисе получаем код с очевидными преимуществами в виде строгой АПИзации блоков.

## Файлы и ENB-сборка

До сих пор мы говорили про index.bt.js, в которм есть шаблоны для всех блоков, которые мы хотим видеть на странице.
И у вас могло сложиться впечатление, что для каждой страницы мы пишем одни и те же шаблоны. Нет, это было бы глупо. Как бы мы тогда реиспользовали код?

В реальности этот  файл генерируется автоматически, мы не пишем его руками. Мы его даже не коммитим. Он создаётся при сборке проекта.

Внутри бивиса есть сборщик. Какие вы знаете? Ant, Make, Grunt? Мы написали ещё один. Знакомьтесь - [ENB](https://github.com/enb-make/enb)

[  ТУТ СНОВА ВЫХОДИТ МАРАТ ]

Зачем он нужен, если есть другие? Наш сборщик отличается тем, что собирает любые проекты, которые строятся на модели node / target.
А второая причина - он очень быстрый. Прям очень-очень быстрый. Нереально быстрый. И в нём есть встроенный сервер, он автоматически отслеживает
изменения на фаловой системе и пересобирает файлы.

ENB собирает страничные файлы из файлов блока.
Если мы думаем о странице, как о наборе модульных блоков, тогда и на файловой системе мы представляем их тоже отдельно.
````
/blocks
    /header
        header.bt.js
        header.styl
        header.js
    /form
        form.bt.js
        form.styl
        form.js
````
Каждый блок хранится в своей собственной папке, где шаблоны для генераиции html в bt.js, стили в styl, клиентский яваскрипт в js.
Эффективно, хотя и не ново. Когда моя дочка готовится к математике, она на парту выкладывает учебник по математике, тетрадь по математике,
угольник и карандаш — всё, что нужно именно для урока математики. У нас так же - всё, что нужно для блока находится в одной папке.






## Статические ресурсы

С помощью шаблонов мы создаём index.html и отдаём в браузер.

Кроме html передаётся в браузер, нужно передать ещё и CSS и JS. То есть статические файлы, которые нужны
исключительно для раскрашивания тегов в браузере и для придания тегам какой-то интерактивности.



